{"meta":{"title":"晓阳","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2018-06-03T11:01:03.315Z","updated":"2018-06-03T11:01:03.315Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-06-03T11:01:03.317Z","updated":"2018-06-03T11:01:03.317Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2018-06-03T11:01:03.313Z","updated":"2018-06-03T11:01:03.313Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"spring-webflux简介与示例","slug":"spring-webflux","date":"2018-06-16T03:28:25.000Z","updated":"2018-06-16T03:36:09.230Z","comments":true,"path":"2018/06/16/spring-webflux/","link":"","permalink":"http://yoursite.com/2018/06/16/spring-webflux/","excerpt":"简介 Spring WebFlux是Spring Framework 5.0中引入的新的反应式Web框架。与Spring MVC不同，它不需要Servlet API，完全异步和非阻塞，并通过Reactor项目实现Reactive Streams规范。并且可以在诸如Netty，Undertow和Servlet 3.1+容器的服务器上运行。","text":"简介 Spring WebFlux是Spring Framework 5.0中引入的新的反应式Web框架。与Spring MVC不同，它不需要Servlet API，完全异步和非阻塞，并通过Reactor项目实现Reactive Streams规范。并且可以在诸如Netty，Undertow和Servlet 3.1+容器的服务器上运行。 Reactor中的Mono和Flux Flux 和 Mono 是 Reactor 中的两个基本概念。Flux 表示的是包含 0 到 N 个元素的异步序列。在该序列中可以包含三种不同类型的消息通知：正常的包含元素的消息、序列结束的消息和序列出错的消息。当消息通知产生时，订阅者中对应的方法 onNext(), onComplete()和 onError()会被调用。Mono 表示的是包含 0 或者 1 个元素的异步序列。该序列中同样可以包含与 Flux 相同的三种类型的消息通知。Flux 和 Mono 之间可以进行转换。对一个 Flux 序列进行计数操作，得到的结果是一个 Mono对象。把两个 Mono 序列合并在一起，得到的是一个 Flux 对象。 了解更多 WebFlux的使用方式 如图所示，WebFlux支持两种编程方式 基于SpringMvc注解@Controller 基于Java8 lambda样式路由和处理 使用WebFlux需要单独引用它的依赖,我使用的springboot,依赖如下： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--reactor的测试依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 示例 基于SpringMvc注解 与使用SpringMvc不同的是使用SpringWebFlux同一使用Mono&lt;&gt;,Flux&lt;&gt;对象同意返回数据，如下 1234567891011121314151617181920212223242526@RestController@RequestMapping(\"/api/user\")public class WebFluxController &#123; private Map&lt;Long,User&gt; map = new HashMap&lt;Long,User&gt;(10); @PostConstruct public void init()&#123; map.put(1L,new User(1,\"admin\",\"admin\")); map.put(2L,new User(1,\"admin2\",\"admin2\")); map.put(3L,new User(1,\"admin3\",\"admin3\")); &#125; @GetMapping(\"/getAll\") public Flux&lt;User&gt; getAllUser()&#123; return Flux.fromIterable(map.entrySet().stream().map(Map.Entry::getValue) .collect(Collectors.toList())); &#125; @GetMapping(\"/&#123;id&#125;\") public Mono&lt;User&gt; getUserById(@PathVariable(\"id\") Long id)&#123; return Mono.just(map.get(id)); &#125; @PostMapping(\"/save\") public Mono&lt;ResponseEntity&lt;String&gt;&gt; save(@RequestBody User user)&#123; map.put(user.getUid(),user); return Mono.just(new ResponseEntity&lt;&gt;(\"添加成功\", HttpStatus.CREATED)); &#125;&#125; 具体实现代码可查看springboot-webflux 基于功能 处理请求的类，实现具体的业务逻辑，接口 ServerRequest 表示的是一个 HTTP 请求体。通过ServerRequest 对象可获取到请求的相关信息，如请求路径、查询参数和请求内容等。方法 的返回值是一个 Mono对象。接口 ServerResponse 用来表示 HTTP 响应。ServerResponse 中包含了很多静态方法来创建不同 HTTP 状态码的响应对象 123456789101112131415161718192021222324252627@Componentpublic class UserHandler &#123; private IUserService userService; @Autowired public UserHandler(IUserService userService) &#123; this.userService = userService; &#125; public Mono&lt;ServerResponse&gt; getAllUser(ServerRequest serverRequest)&#123; Flux&lt;User&gt; allUser = userService.getAllUser(); return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(allUser,User.class); &#125; public Mono&lt;ServerResponse&gt; getUserById(ServerRequest serverRequest)&#123; //获取url上的id Long uid = Long.valueOf(serverRequest.pathVariable(\"id\")); Mono&lt;User&gt; user = userService.getUserById(uid); return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(user,User.class); &#125; public Mono&lt;ServerResponse&gt; saveUser(ServerRequest serverRequest)&#123; Mono&lt;User&gt; user = serverRequest.bodyToMono(User.class); return ServerResponse.ok().build(userService.saveUser(user)); &#125;&#125; 为Handler类添加路由信息， 123456789101112@Configurationpublic class RoutingConfiguration &#123; @Bean public RouterFunction&lt;ServerResponse&gt; monoRouterFunction(UserHandler userHandler)&#123; return route(GET(\"/api/user\").and(accept(MediaType.APPLICATION_JSON)),userHandler::getAllUser) .andRoute(GET(\"/api/user/&#123;id&#125;\").and(accept(MediaType.APPLICATION_JSON)),userHandler::getUserById) .andRoute(POST(\"/api/save\").and(accept(MediaType.APPLICATION_JSON)),userHandler::saveUser); &#125;&#125; 具体实现代码可查看springboot-webflux-functional","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"java","slug":"编程语言/java","permalink":"http://yoursite.com/categories/编程语言/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"webflux","slug":"webflux","permalink":"http://yoursite.com/tags/webflux/"}]},{"title":"Java Nio中的缓冲区与通道","slug":"Java-nio","date":"2018-05-30T12:46:25.000Z","updated":"2018-06-05T13:52:20.269Z","comments":true,"path":"2018/05/30/Java-nio/","link":"","permalink":"http://yoursite.com/2018/05/30/Java-nio/","excerpt":"Java NIO简介 Java NIO（New IO）是用于Java（来自Java 1.4）的替代IO API，意味着替代标准 Java IO和Java Networking API，Java NIO提供了与原来IO API不同的工作方式，但是作用和目的是一样的。NIO支持面向缓冲区的，基于通道的IO操作，NIO将以更加高效的方式进行文件的读写操作。","text":"Java NIO简介 Java NIO（New IO）是用于Java（来自Java 1.4）的替代IO API，意味着替代标准 Java IO和Java Networking API，Java NIO提供了与原来IO API不同的工作方式，但是作用和目的是一样的。NIO支持面向缓冲区的，基于通道的IO操作，NIO将以更加高效的方式进行文件的读写操作。 Java NIO与普通IO的主要区别 io nio 面向流 面向缓冲区（buffer，channel） 堵塞io 非堵塞io - 选择器 java nio主要的核心组件 缓冲区 buffer 通道 Channels 选择器 Selectors java nio缓冲区buffer 简介 Buffer是数据的容器，在nio中负责数据的存取，java为不同数据类型提供了相对应的缓冲区类型 如：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer 、DoubleBuffer 等。 Buffer的基本使用 通过allocate()方法获取缓冲区，put()方法存入数据到缓冲区，get()方法获取缓冲区中的数据 123456789101112String temp = \"abcdefg\";//通过allocate()方法获取指定大小的缓冲区ByteBuffer byteBuffer = ByteBuffer.allocate(1024);//使用put()方法将数据添加到缓冲区byteBuffer.put(temp.getBytes());//缓冲区切换读取数据模式byteBuffer.flip();//获取缓冲区数据byte[] dst = new byte[byteBuffer.limit()];//使用get()方法获取数据到dst中byteBuffer.get(dst);System.out.println(new String(dst,0,dst.length)); Buffer的核心属性 capacity:容量，表示缓冲区中最大存储数据的容量，一旦声明不能改变。 limit:界限，表示缓冲区中可以操作数据的大小。（limit后数据不能进行读写） position:位置，表示缓冲区中正在操作数据的位置 mark: 标记，表示记录当前position的位置，可通过reset()恢复到mark的位置 mark &lt;= position &lt;= limit &lt;= capacity，属性的各种状态的值可查看TestBuffer.java中的测试代码 直接缓冲区与非直接缓冲区 非直接缓冲区：通过allocate()分配缓冲区，缓冲区建立在jvm中。 直接缓冲区：通过allocateDirect()方法创建缓冲区，缓冲区建立在系统物理内存中。 java nio通道channel 简介 通道（channel）：用户数 据源节点和目标节点的连接。在Java nio中负责缓冲区中的数据传输， channel本身不存储数据，因此需要配合缓冲区进行传输,实现java.nio.channels.Channel接口 ，主要实现类有FileChannel、SocketChannel、ServerSocketChannel、DatagramChannel等。 获取通的方式 (1)java针对支持通道的类提供getChannel()方法本地IO有：FileInputStream/FileOutputStream、RandomAccessFile， 网络IO有：Socket、ServerSocket、DatagramSocket (2)在Java1.7中的NIO.2针对各个通道提供了静态方法open() (3)在Java1.7中的NIO.2的Files工具类的newByteChannel() 简单示例 12345678910111213141516171819202122//使用非直接缓冲区FileInputStream fis = new FileInputStream(\"chao.png\");FileOutputStream fos = new FileOutputStream(\"chao2.png\");//1.获取通道FileChannel inChannel = fis.getChannel();FileChannel outChannel = fos.getChannel();//2.分配指定大小缓冲区ByteBuffer buffer = ByteBuffer.allocate(3072);//3.将通道的数据存入缓冲区while (inChannel.read(buffer)!=-1)&#123; //缓冲区切换为读模式 buffer.flip(); //4.将缓冲区数据写入通道 outChannel.write(buffer); buffer.clear();&#125;outChannel.close();inChannel.close();fis.close();fos.close(); 更多示例代码可查阅官方api文档","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"java","slug":"编程语言/java","permalink":"http://yoursite.com/categories/编程语言/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"nio","slug":"nio","permalink":"http://yoursite.com/tags/nio/"}]}]}