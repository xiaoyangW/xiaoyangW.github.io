{"meta":{"title":"晓阳","subtitle":null,"description":null,"author":"John Doe","url":"http://wxiaoyang.top"},"pages":[{"title":"Categories","date":"2018-06-03T11:01:03.315Z","updated":"2018-06-03T11:01:03.315Z","comments":true,"path":"categories/index.html","permalink":"http://wxiaoyang.top/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-06-03T11:01:03.313Z","updated":"2018-06-03T11:01:03.313Z","comments":true,"path":"about/index.html","permalink":"http://wxiaoyang.top/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-06-03T11:01:03.317Z","updated":"2018-06-03T11:01:03.317Z","comments":true,"path":"tags/index.html","permalink":"http://wxiaoyang.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring-Cloud-Gateway简介与使用","slug":"gateway","date":"2019-05-03T12:46:25.000Z","updated":"2019-05-04T12:59:02.597Z","comments":true,"path":"2019/05/03/gateway/","link":"","permalink":"http://wxiaoyang.top/2019/05/03/gateway/","excerpt":"官方简介该项目提供了一个建立在Spring Ecosystem之上的API网关，包括：Spring 5，Spring Boot 2和Project Reactor。Spring Cloud Gateway旨在提供一种简单而有效的方式来对API进行路由，并为他们提供切面，例如：安全性，监控/指标 和弹性等。","text":"官方简介该项目提供了一个建立在Spring Ecosystem之上的API网关，包括：Spring 5，Spring Boot 2和Project Reactor。Spring Cloud Gateway旨在提供一种简单而有效的方式来对API进行路由，并为他们提供切面，例如：安全性，监控/指标 和弹性等。 官方工作原理介绍 客户端向spring-cloud-gateway请求网关映射处理程序(gateway handler mapping)，如果确认请求与路由匹配，则将请求发送到web处理程序(gateway web handler)，web处理程序通过特定于该请求的过滤器链处理请求，图中filters被虚线划分的原因是filters可以在发送代理请求之前(pre filter)或之后执行逻辑(post filter)。先执行所有pre filter逻辑，然后进行请求代理。在请求代理执行完后，执行post filter逻辑。 开始使用Spring-Cloud-Gateway Spring Cloud Gateway依赖Spring Boot和Spring Webflux提供的Netty runtime，所以springboot必须在2.0或者以上，springcloud在Finchley以上，基本springcloud环境确认后，然后引入： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt; 再将服务作为Eureka客户端注册至Eureka注册中心，这里省略，可以在GitHub代码中查看 路由配置官网都是用的yml配置文件配置，与properties配置文件配置稍有不同，我这里全部使用properties配置文件配置。 直接使用注册中心路由配置1234#使用服务发现路由spring.cloud.gateway.discovery.locator.enabled=true#服务路由名小写spring.cloud.gateway.discovery.locator.lower-case-service-id=true 指定服务配置123456#设置路由idspring.cloud.gateway.routes[0].id=auth-service#设置路由的urispring.cloud.gateway.routes[0].uri=lb://auth-service#设置路由断言,代理servicerId为auth-service的/auth/路径spring.cloud.gateway.routes[0].predicates[0]= Path=/auth/** spring.cloud.gateway.routes.predicates：路由断言，配置时必须得有一项，不一定是Path； spring.cloud.gateway.routes.uri：配置路由uri，”lb:’serviceId’”前代表路由的服务，同时也可以是一个url 编码服务配置1234567891011@Configurationpublic class RoutesConfiguration &#123; @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) &#123; return builder.routes().route(predicateSpec -&gt; predicateSpec.path(\"/auth/**\").uri(\"lb://auth-service\").id(\"auth-service\") ).build(); &#125;&#125; 总结Spring-Cloud-Gateway与Zuul 1.0相比，前者基于WebFlux与Reactive线程模型的异步非阻塞框架，服务通过底层的Netty来进行发布及运行，异步非阻塞可以有效降低系统的线程数量，只需要很少的线程就可以完成较高的并发支持，而Zuul1.0是基于servlet性能上的差距可想而知，同时Spring-Cloud-Gateway还内置了许多的路由断言(Factories)与过滤器(Filter)可以减少开发人员的编码，和更好的功能支持和扩展。 示例代码 spring-cloud-gateway中文文档","categories":[{"name":"microservice","slug":"microservice","permalink":"http://wxiaoyang.top/categories/microservice/"},{"name":"springcloud","slug":"microservice/springcloud","permalink":"http://wxiaoyang.top/categories/microservice/springcloud/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://wxiaoyang.top/tags/springcloud/"},{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://wxiaoyang.top/tags/springboot/"},{"name":"gateway","slug":"gateway","permalink":"http://wxiaoyang.top/tags/gateway/"}]},{"title":"分布式事务 2PC-3PC协议","slug":"2pc-3pc","date":"2019-03-23T06:42:25.000Z","updated":"2019-03-23T06:45:57.712Z","comments":true,"path":"2019/03/23/2pc-3pc/","link":"","permalink":"http://wxiaoyang.top/2019/03/23/2pc-3pc/","excerpt":"两阶段提交协议-2PC两阶段提交协议(2PC)：是一种原子承诺协议，一种分布式算法，它协调参与分布式事务的所有应用（进程）是否提交或终止（回滚）事务， 2PC基本算法 阶段一：提交事务询问请求（或投票）阶段 事务协调者（TM）向所有参与该事务的进程发送事务内容，询问是否可以执行该事务的提交，并等待所有AP的响应 每个AP节点执行事务操作，将undo和redo信息记录到事务日志中，尽量把提交过程中所消耗时间的操作和准备都提前完成后确保后续事务提交的成功率（undo log-回滚日志，redo log-重做日志） 每个AP向TM回复协议消息（投票），如果AP执行成功则投票赞成，如果AP回复协议消息失败或者出现无法预知的错误则投票不赞成","text":"两阶段提交协议-2PC两阶段提交协议(2PC)：是一种原子承诺协议，一种分布式算法，它协调参与分布式事务的所有应用（进程）是否提交或终止（回滚）事务， 2PC基本算法 阶段一：提交事务询问请求（或投票）阶段 事务协调者（TM）向所有参与该事务的进程发送事务内容，询问是否可以执行该事务的提交，并等待所有AP的响应 每个AP节点执行事务操作，将undo和redo信息记录到事务日志中，尽量把提交过程中所消耗时间的操作和准备都提前完成后确保后续事务提交的成功率（undo log-回滚日志，redo log-重做日志） 每个AP向TM回复协议消息（投票），如果AP执行成功则投票赞成，如果AP回复协议消息失败或者出现无法预知的错误则投票不赞成 阶段二：提交事务阶段 阶段一成功执行事务：协调者（TM）在提交事务请求阶段收到来自所有AP的协议消息 TM向所有AP发送事务提交消息 每个AP执行事务操作，并释放事务期间所有持有的锁和资源 每个AP向TM发送事务确认的协议消息 TM收到所有AP的确认消息完成本次事务 阶段一失败中断事务：任何AP投票否或者TM超时 TM向所有AP发送事务回滚消息 每个AP根据回滚日志（undo log）撤销事务，并释放事务期间所有持有的锁和资源 每个AP向TM发送确认消息 TM收到所有的确认消息后撤销该事务 2PC的缺点 同步堵塞：两阶段提交协议最大的缺点就是它是一种堵塞协议，在事务询问阶段AP向TM发送协议消息后，AP将堵塞，直到AP收到TM提交或回滚事务 数据一致性：如果在执行阶段二时TM或者部分AP不可用，部分AP执行事务不成功，导致数据不一致 三阶段提交协议-3PC3PC是2PC的升级版，与2PC最大的不同就是3PC它是非堵塞的，具体就是在事务提交或者中止之前增加了一种超时机制，当超过这个时间上限还未提交事务，就会把该事务绑定的资源释放掉 3PC算法 阶段一：canCommit（投票） TM接收到事务请求后，向所有事务参与者发送canCommit请求，等待参与者返回信息，如果TM在接收事务请求时出现故障或者不可用，TM将直接中止事务。 事务参与者接收到一个来自TM的canCommit请求后，如果参与者都同意后会向TM回复yes消息并进入准备状态，如果参与者获取资源失败或者出现不可用会回复no中止事务。 阶段二：preCommit（预提交） TM在超时时间内收到yes消息后，会向所有的参与者发送preCommit消息，如果出现故障，超时或者TM收到no消息，TM将向所有参与者发送中止事务的消息。 所有等待中的参与者如果收到preCommit消息会发挥ACK消息并等待最终提交或中止事务，如果搜道协调者中止消息，失败或者超时等待则会中止事务。 阶段三：doCommit（提交） 如果协调者正常工作并收到了所有参与者的ACK消息，它会向所有的参与者发送doCommit消息，如果超时时间范围内未收到或者部分未收到等情况，协调者向所有的参与者发送中止事务消息。 如果参与者接收到doCommit消息，会正式提交事务，并释放整个事务期间占用的资源，然后向TM反馈ACK消息，如果收到来自TM的中止消息参与者会根据阶段一的undo log回滚事务，并释放所有的事务资源并向TM反馈ACK信息。完成事务。。 3PC的缺点在阶段三如果协调者在超时范围内未提交doCommit消息或者中止消息，参与者在超时后会继续进行事务的提交，如果doCommit没问题但是如果是中止服务的话参与者还会自动提交事务这样可能导致本来的事务回滚变成了事务提交。 参阅：https://en.wikipedia.org/wiki/Two-phase_commit_protocolhttps://en.wikipedia.org/wiki/Three-phase_commit_protocol","categories":[{"name":"microservice","slug":"microservice","permalink":"http://wxiaoyang.top/categories/microservice/"},{"name":"分布式事务","slug":"microservice/分布式事务","permalink":"http://wxiaoyang.top/categories/microservice/分布式事务/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://wxiaoyang.top/tags/springcloud/"},{"name":"事务","slug":"事务","permalink":"http://wxiaoyang.top/tags/事务/"}]},{"title":"分布式事务与X/Open DTP模型","slug":"dtp","date":"2019-03-17T07:32:25.000Z","updated":"2019-03-18T13:11:32.796Z","comments":true,"path":"2019/03/17/dtp/","link":"","permalink":"http://wxiaoyang.top/2019/03/17/dtp/","excerpt":"事务的特征 Atomic：原子性，事务必须是一个原子的工作单元,要么全部成功，要么全部失败 Consistent：一致性，事务完成时必须使所有的数据保持一致状态。 Isolation：隔离性，并发事务所做的修改必须与其他事务所做的修改是隔离的。 Duration：持久性，事务完成后对系统的影响是永久性的。","text":"事务的特征 Atomic：原子性，事务必须是一个原子的工作单元,要么全部成功，要么全部失败 Consistent：一致性，事务完成时必须使所有的数据保持一致状态。 Isolation：隔离性，并发事务所做的修改必须与其他事务所做的修改是隔离的。 Duration：持久性，事务完成后对系统的影响是永久性的。 分布式事务的由来随着系统用户和数据的增加，原先的单体应用的程序架构向着SOA或者微服务的架构发展，数据库也会有分库分表等操作来提高效率 单体应用 单体应用只有一个操作的数据库，完全可以直接依赖数据库的ACID特性和应用的事务管理来保证事务的执行，数据的一致性。 分布式应用 分布式应用中每个模块的应用都对应一个数据库时候，事务管理已经跨应用了，如上图，加入张三下单买东西，要在用户中心添加订单记录，订单中心要去删减库存，对一个整体的应用而言这是一个原子操作，要么两个操作全部成功要么全部失败，来保证数据的一致性。 X/Open DTP事务模型X/Open DTP 全称 X/Open Distributed Transaction Processing Reference是X/Open这个组织定义出的一套分布式事务标准 X/Open DTP中的角色 AP(Application Program)：应用程序，主要是定义事务边界以及那些组成事务的特定于应用程序的操作。 EM(Resouces Manager)：资源管理器，管理一些共享资源的自治域，如提供对诸如数据库之类的共享资源的访问。 TM(Transaction Manager)：事务管理器，管理全局事务，协调事务的提交或者回滚，并协调故障恢复。 DTP模型执行流程 第一步：AP使用一组来自RM的资源 第二步：AP通过TM接口定义事务的边界 第三步：TM和RM交换事务信息","categories":[{"name":"microservice","slug":"microservice","permalink":"http://wxiaoyang.top/categories/microservice/"},{"name":"分布式事务","slug":"microservice/分布式事务","permalink":"http://wxiaoyang.top/categories/microservice/分布式事务/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://wxiaoyang.top/tags/springcloud/"},{"name":"事务","slug":"事务","permalink":"http://wxiaoyang.top/tags/事务/"}]},{"title":"Spring Cloud Alibab Nacos注册中心与配置中心","slug":"nacos","date":"2019-03-15T03:46:25.000Z","updated":"2019-03-16T04:03:09.926Z","comments":true,"path":"2019/03/15/nacos/","link":"","permalink":"http://wxiaoyang.top/2019/03/15/nacos/","excerpt":"nacos简介Nacos由阿里巴巴开源，致力于服务发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理，Nacos 已经支持几乎所有主流类型的“服务”的发现、配置和管理。主要包括的功能有：服务发现和服务健康监测，动态配置服务，动态 DNS 服务，服务及其元数据管理 安装Nacos请参阅：https://nacos.io/zh-cn/docs/quick-start.html","text":"nacos简介Nacos由阿里巴巴开源，致力于服务发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理，Nacos 已经支持几乎所有主流类型的“服务”的发现、配置和管理。主要包括的功能有：服务发现和服务健康监测，动态配置服务，动态 DNS 服务，服务及其元数据管理 安装Nacos请参阅：https://nacos.io/zh-cn/docs/quick-start.html SpringCloud使用Nacos注册服务 添加对spring-cloud-alibaba的依赖 1234567&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 主要的作用是对spring-cloud-alibaba中的包的版本控制。 添加nacos客户端包 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 启动服务注册 添加@EnableDiscoveryClient标签启动服务注册，如： 12345678@SpringBootApplication@EnableDiscoveryClientpublic class ServiceProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceProviderApplication.class, args); &#125;&#125; 添加nacos客户端配置 1234server.port=9002spring.application.name=service-consumerspring.cloud.nacos.discovery.server-addr=172.30.251.129:8848(nacos运行地址)management.endpoints.web.exposure.include=* 启动这启动好就可以在nacos控制台看见注册的服务了 SpringCloud使用Nacos动态配置服务 添加spring-cloud-alibaba的pom统一依赖后，添加spring-cloud-alibaba的配置服务客户端依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; 属性文件添加配置 12spring.cloud.nacos.config.server-addr=172.30.251.129:8848spring.cloud.nacos.config.name=service-provider 这要注意springboot中application.properties(yml)与bootstrap.poperties(yml)的区别，这里配置文件应加在bootstrap.poperties(yml)中，bootstrap.poperties(yml)是应用于应用上下文中的引导阶段，由父ApplicationContext加载，可以理解为系统配置，一般不变动，比application.properties(yml)先加载。 使用配置信息，如： 12345678910111213@RefreshScope@RestController@RequestMapping(\"/provider\")public class ProviderController &#123; @Value(\"$&#123;name&#125;\") String name; @GetMapping(\"/config\") public String config()&#123; return name; &#125;&#125; @RefreshScope用于刷新配置，当配置修改后Nacos会主动刷新配置 多环境配置 1spring.profiles.active=dev 注意事项Spring Cloud Alibaba 版本与SpringCloud版本对应的兼容关系 Spring Cloud Alibaba Version SpringCloud Version 0.2.1.RELEASE Spring Cloud Finchley 0.1.1.RELEASE Spring Cloud Edgware SpringBoot与SpringCloud版本对应关系 Spring Cloud Version Spring Boot Version Greenwich 2.1.x Finchley 2.0.x Edgware 1.5.x Dalston 1.5.x 代码地址：https://github.com/xiaoyangW/spring-cloud-alibaba-demonstrate个人博客：https://wxiaoyang.top","categories":[{"name":"microservice","slug":"microservice","permalink":"http://wxiaoyang.top/categories/microservice/"},{"name":"springcloud","slug":"microservice/springcloud","permalink":"http://wxiaoyang.top/categories/microservice/springcloud/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://wxiaoyang.top/tags/springcloud/"},{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://wxiaoyang.top/tags/springboot/"},{"name":"nacos","slug":"nacos","permalink":"http://wxiaoyang.top/tags/nacos/"},{"name":"springcloud-alibaba","slug":"springcloud-alibaba","permalink":"http://wxiaoyang.top/tags/springcloud-alibaba/"}]},{"title":"redis数据类型及常用命令","slug":"redis-data-type","date":"2018-12-31T10:54:25.000Z","updated":"2018-12-30T10:57:33.610Z","comments":true,"path":"2018/12/31/redis-data-type/","link":"","permalink":"http://wxiaoyang.top/2018/12/31/redis-data-type/","excerpt":"string（字符串）string类型是redis的最基本数据类型，一个key对应value；string类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象；string类型的值最大能存储512MB","text":"string（字符串）string类型是redis的最基本数据类型，一个key对应value；string类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象；string类型的值最大能存储512MBredis操作指令： 12345678910111213141516//添加set $key $value 如 set name \"张三\"//添加多个mset $key $value $key $value....如 mset sex 23 sds ss//获取get $key 如 get name//获取多个key的value值mget $key 如 mget name name2//数字递增incr $key 如 incr num ，value值必须是整数//递减decr $key 如 decr num //指定key追加字符append $key $value 如 append name ss ，成功会返回value值的长度//获取key的value值长度strlen $key 如 strlen name hash(哈希，散列)hash 是一个键值对集合，是字符串字段和字符串值之间的映射，因此它们是表示对象的完美数据类型（例如，具有多个字段的用户，如姓名，姓氏，年龄等） 123456789101112//添加数据hmset $key &#123;$key $value ...&#125; 如hmset user name 晓阳 sex 1//获取数据hget $key &#123;$key&#125; 如hget user name 获取user中的name的value值//获取全部hgetall $key 如hgetall user//字段是否存在（存在返回1不存在返回0）hexists $key &#123;$key&#125; 如 hexists user name//增加字段hsetnx $key &#123;$key $value&#125; 如 hsetnx user sge 18//删除一个或多个字段hdel $key &#123;$key&#125; 如 hdel user name age list(列表)list是字符串列表，按插入顺序排序。列表的最大长度为2的32次方 - 1个元素，从时间复杂度的角度来看，Redis列表的主要特征是支持在头部和尾部附近恒定时间插入和删除元素，即使有数百万个插入项目。访问元素在列表的极端附近非常快，但如果您尝试访问非常大的列表的中间，则速度很慢，因为它是O（N）操作。 12345678910//从左边或右边添加数据lpush/rpush $key $value $value.. 如 lpush list1 sss//获取列表长度llen $key //取数据lrange $key $start $stop 如 lrange list1 0 10//从左或右删除并返回数据(可以用来做分布式消息队列)lpop/rpop $key 如 lpop list1 删除并返回value值//替换valuelset $key $row $value 如 lset list1 0 ss set(集合) set是一个无序的字符串集合，集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)，与list不一样的是集合类型不能存在重复数据。 12345678//添加setsadd $key $value.. 如sadd set1 1 2 3//删除set中的指定value值srem $key $value 如srem set1 2//比较俩个集合不同sdiff $key $key 如 sdiff set1 set2 意思是set1存在set2不存在//合并集合sunion $key $key 如sunion set1 set2 zset(sorted set:有序集合)zset 和 set 一样也是string类型元素的集合,且不允许重复的成员，不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序，zset的成员是唯一的,但分数(score)却可以重复。 1234//添加,score为分数zadd $key $score $value 如zadd zset1 100 haha//获取元素zrange $key $start $end 如zrange zset1 0 2，获取前三个元素 如果两个元素的score是相同的话，那么根据(0&lt;9&lt;A&lt;Z&lt;a&lt;z) 方式从小到大 redis中的事务MULTI 去开启事务，EXEC 去执行事务 如： 123456789redis-test:0&gt;MULTI\"OK\"redis-test:0&gt;set string 222\"QUEUED\"redis-test:0&gt;set ss ss\"QUEUED\"redis-test:0&gt;EXEC 1) \"OK\" 2) \"OK\" redis文档","categories":[{"name":"nosql","slug":"nosql","permalink":"http://wxiaoyang.top/categories/nosql/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://wxiaoyang.top/tags/redis/"}]},{"title":"DOCKER编排SpringCloud微服务","slug":"docker-arrange","date":"2018-12-20T12:38:25.000Z","updated":"2018-12-20T12:50:46.727Z","comments":true,"path":"2018/12/20/docker-arrange/","link":"","permalink":"http://wxiaoyang.top/2018/12/20/docker-arrange/","excerpt":"后面所有的步骤都依赖于开发环境，如果环境不同可能会存在兼容人体，我的开发环境如下： 操作系统：windows 10 企业版 docker for windows：2.0.0.0-win81 docker engine：18.09.0 docker compose：1.23.2","text":"后面所有的步骤都依赖于开发环境，如果环境不同可能会存在兼容人体，我的开发环境如下： 操作系统：windows 10 企业版 docker for windows：2.0.0.0-win81 docker engine：18.09.0 docker compose：1.23.2 springboot项目构建docker镜像 maven添加构建docker插件 1234567891011121314151617181920212223242526272829303132&lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; //要生成的docker镜像的名称 &lt;repository&gt;$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;&lt;/repository&gt; &lt;/configuration&gt;&lt;/plugin&gt;//将jar解压成目录结构&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;unpack&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;unpack&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;artifactItems&gt; &lt;artifactItem&gt; &lt;groupId&gt;$&#123;project.groupId&#125;&lt;/groupId&gt; &lt;artifactId&gt;$&#123;project.artifactId&#125;&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/artifactItem&gt; &lt;/artifactItems&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 在项目根目录（与pom.xml同级）下添加Dockerfile，如： 12345678FROM openjdk:8-jdk-alpineVOLUME /tmpARG DEPENDENCY=target/dependencyCOPY $&#123;DEPENDENCY&#125;/BOOT-INF/lib /app/libCOPY $&#123;DEPENDENCY&#125;/META-INF /app/META-INFCOPY $&#123;DEPENDENCY&#125;/BOOT-INF/classes /appEXPOSE 8070ENTRYPOINT [\"java\",\"-cp\",\"app:app/lib/*\",\"$&#123;springboot项目的启动类&#125;\"] 上面的Dockerfile一定要把${springboot项目的启动类}替换为自己项目的启动目录如com.xiaoyang.Application,其中Application是项目的启动类。 将项目打包打包成docker镜像 方法一：可以直接使用命令(需要配置maven环境变量)： 1mvn clean package dockerfile:build 可能会出现的问题，如： 1[ERROR] Failed to execute goal com.spotify:dockerfile-maven-plugin:1.3.6:build (default-cli) on project crm_service_member: Could not build image: java.util.concurrent.ExecutionException:com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: org.apache.http.conn.HttpHostConnectException: Connect to localhost:2375 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: connect -&gt; [Help 1] 解决发放（docker for windows）在没有TLS的tcp:// localhost:2375上公开守护进程,如图设置docker for windows : 方法二，如果方法一实在不能行可以使用方法二（略麻烦，但可以跳过方法一说所的问题）： 第一步、先编译好项目，在项目根目录下： 1mvn clean package 第二步、直接使用docker命令运行Dockerfile生成镜像： 12docker build -t [IMAGE_NAME]:[TAG] PATH如：docker build -t config:v1 . IMAGE_NAME：docker镜像名 TAG：docker镜像tag PATH：Dockerfile所在路径 其他：可以直接使用IDEA的工具运行指令。 docker-compose服务编排当所有要发布的项目都打包编译好生成docker镜像后，就可以统一使用docker-compose进行服务的编排。 在项目根目录下建立docker-compose.yml,内容如： 1234567891011121314151617eureka: image: spring-cloud-eureka ports: - 8070:8070config: image: spring-cloud-config ports: - 8072:8072 links: - centeruser: image: user-server ports: - 8081:8081 links: - center - config 说明: eureka、config、user是发布的别名，不固定 image是要发布的docker镜像名 ports是docker服务的端口转发 links是当前运行的docker镜像需要访问的docker镜像 对服务的修改： ​ docker镜像与docker镜像之间访问要采用别名，如config要访问eureka ​ 使用别名如： 12345678eureka: instance: prefer-ip-address: true client: registerWithEureka: true fetchRegistry: true serviceUrl: defaultZone: http://center:8070/eureka/ 调用配置中心类似 docker-compose启动顺序问题当我们有多个服务相互依赖，有的时候会出现当前容器所依赖的服务没有启动完成导致当前容器启动失败，如上述的docker-compose.yml的方式构建就会出现这种情况。 使用depends_on指定依赖服务，使用restart重启服务，如： 1234567891011121314151617181920212223version: \"3\"services: eureka: image: spring-cloud-eureka ports: - 8070:8070 restart: always config: image: spring-cloud-config ports: - 8072:8072 depends_on: - eureka user: image: user-server restart: always ports: - 8081:8081 depends_on: - eureka - config 其中restart:always代表重启，always表示一直重启，如果启动失败会重新启动，一直失败也会一直重新启动 参考资料http://spring.io/guides/gs/spring-boot-docker/https://docs.docker.com/compose/overview/","categories":[{"name":"microservice","slug":"microservice","permalink":"http://wxiaoyang.top/categories/microservice/"},{"name":"springcloud","slug":"microservice/springcloud","permalink":"http://wxiaoyang.top/categories/microservice/springcloud/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://wxiaoyang.top/tags/springcloud/"},{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"docker","slug":"docker","permalink":"http://wxiaoyang.top/tags/docker/"},{"name":"springboot","slug":"springboot","permalink":"http://wxiaoyang.top/tags/springboot/"}]},{"title":"PostgreSQL数据类型概述","slug":"pgsql-data-type","date":"2018-11-26T12:20:25.000Z","updated":"2018-11-26T12:36:28.850Z","comments":true,"path":"2018/11/26/pgsql-data-type/","link":"","permalink":"http://wxiaoyang.top/2018/11/26/pgsql-data-type/","excerpt":"PostgreSQL支持以下数据类型： 布尔类型（boolean） 字符类型，如char，varchar和text。 数字类型，例如整数和浮点数。 时间类型，如date,time,timestamp 用于存储通用唯一标识符的[UUID] array(数组)，用于存储数组字符串，数字等","text":"PostgreSQL支持以下数据类型： 布尔类型（boolean） 字符类型，如char，varchar和text。 数字类型，例如整数和浮点数。 时间类型，如date,time,timestamp 用于存储通用唯一标识符的[UUID] array(数组)，用于存储数组字符串，数字等 json 存储json数据 hstore存储键值对 特殊类型，如网络地址、几何数据、货币数据等。 布尔一个[布尔]数据类型可以容纳三个可能的值之一：true，false或null。您使用boolean或者 bool来声明具有布尔数据类型的列。 当将数据插入布尔列时，PostgreSQL将其转换为布尔值，例如 1，yes，y，t，true会转换为true；0，no，n, false，f会转换为false。 当您从布尔列中查询数据时候，PostgreSQL会将t值转换为true，将f空格转换为false。 字符PostgreSQL的提供了三种[字符数据类型]：char(n)，varchar(n)，和text char(n)是带有空格填充的固定长度字符。如果插入的字符串短于列的长度，PostgreSQL会填充空格。如果插入的字符串长度超过列的长度，PostgreSQL将发出错误。 varchar(n)是可变长度的字符串。有了varchar(N)，您可以存储最多n字符。当存储的字符串短于列的长度时，PostgreSQL不会填充空格。 text 是可变长度的字符串。从理论上讲，文本数据是一个长度不限的字符串。 数字PostgreSQL提供两种不同类型的数字： 整数 浮点数 整数PostgreSQL中有三种整数： smallint（小整数别名int2）是2字节有符号整数，范围从-32,768到32,767。 integer（别名：int、int4）是一个4字节的整数，范围从-2,147,483,648到-2,147,483,647。 bigint（别名：int8）是一个八字节的整数，范围从-9223372036854775808 到9223372036854775807 serial（别名：serial2、serial4、serial8）最大值与整数相同，只是PostgreSQL会自动生成值并将值填充到serial列中。这类似于MySQL中的AUTO_INCREMENT 浮点数有三种主要类型的浮点数： float(n) 是一个浮点数，其精度至少为n，最多为8个字节。 real或者float8是双精度（8字节）浮点数。 numeric或者numeric(p,s) 是带小数点后带有s数的p位数的实数。这numeric(p,s)是确切的数字。 时间数据类型时态数据类型允许您存储日期和/或时间数据。PostgreSQL有五种主要的时态数据类型： date仅存储日期值。 time存储时间值。 timestamp存储日期和时间值。 timestampz是一种时区感知时间戳数据类型。它是带时区的[时间戳]的缩写。 interval存储一段时间，时间间隔。 这timestampz是PostgreSQL对SQL标准的时间数据类型的扩展。 数组在PostgreSQL中有存储字符串，整数等类型的数组。该数组在某些情况下会派上用场，例如，存储一周中的几天，一年中的几个月。 JSONPostgreSQL提供2种JSON的数据类型：json和jsonb用于存储json数据。 在json需要为每个处理重新分析数据类型存储json数据，而jsonb在二进制格式这是更快处理，但速度慢于插入数据类型存储json数据。另外，jsonb支持索引，这可能是一个优势。 UUID该UUID数据类型允许您存储通用唯一标识符被定义 。这些UUID值保证了更好的唯一性，serial并且可以用于隐藏公开的敏感数据，例如id中的值。 特殊数据类型除原始数据类型外，PostgreSQL还提供了几种与几何和网络相关的特殊数据类型。 box- 一个矩形框。 line- 一组积分。 point- 一对几何数字。 lseg- 线段。 polygon- 封闭的几何形状。 inet- IP4地址。 macaddr- 一个 MAC地址。 money-货币金额","categories":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://wxiaoyang.top/categories/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://wxiaoyang.top/tags/PostgreSQL/"}]},{"title":"zookeeper集群安装","slug":"zk-install","date":"2018-09-25T16:00:00.000Z","updated":"2018-10-22T10:37:15.373Z","comments":true,"path":"2018/09/26/zk-install/","link":"","permalink":"http://wxiaoyang.top/2018/09/26/zk-install/","excerpt":"环境准备 zookeeper安装包：http://www-eu.apache.org/dist/zookeeper/stable/zookeeper-3.4.12.tar.gz centos + java 运行环境，这里我分别准备三台centos虚拟机192.168.146.151，192.168.146.152，192.168.146.153","text":"环境准备 zookeeper安装包：http://www-eu.apache.org/dist/zookeeper/stable/zookeeper-3.4.12.tar.gz centos + java 运行环境，这里我分别准备三台centos虚拟机192.168.146.151，192.168.146.152，192.168.146.153 安装配置 解压zookeeper安装包，tar -zxvf zookeeper-3.4.12.tar.gz ,解压后目录 添加zookeeper配置，进入conf目录，使用cp zoo_sample.cfg zoo.cfg 复制zoo_sample.cfg为zoo.cfg 修改后配置 12345678910111213141516171819202122232425262728293031# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial # synchronization phase can takeinitLimit=10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just # example sakes.dataDir=/tmp/zookeeper# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1server.1=192.168.146.151:2188:3181server.2=192.168.146.152:2188:3181server.3=192.168.146.153:2188:3181 主要配置说明 ​ clientPort运行端口号 ​ dataDir数据存储位置 myid设置 ​ 当安装zookeeper集群环境时要在dataDir目录下创建当前zookeeper的myid ​ 如我在192.168.146.151机器上创建在/tmp/zookeeper/myid文件，文件内容为1，依次类推 。 添加server集群配置 ​ server.1=192.168.146.151:2188:3181–&gt;server.myid=ip:clientPort:prot，有几台机器添加几条配置 ，注意两个端口号不可以重复（如果重复会出现端口号重复的问题）,如上配置。 启动运行，进入每台机器zookeeper目录中的bin文件夹，运行zkServer.sh脚本，如 sh zkServer.sh start ,运行时可在启动目录下查看zookeeper.out 控制台日志。 启动好了可通过运行bin目录下的zkCli.sh脚本连接zookeeper，如 也可通过sh zkServer.sh status 查看当前zookeeper是什么角色 注：zookeeper 集群角色分为leader、follower、observer，这里我配置的只有leader和follower，要台添加一台observer机器，在server配置后面标记为observer如：server.4=192.168.146.154:2188:3181:observer","categories":[{"name":"microservice","slug":"microservice","permalink":"http://wxiaoyang.top/categories/microservice/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://wxiaoyang.top/tags/linux/"}]},{"title":"Java 代理模式","slug":"proxy","date":"2018-07-18T08:46:25.000Z","updated":"2018-07-19T13:39:22.619Z","comments":true,"path":"2018/07/18/proxy/","link":"","permalink":"http://wxiaoyang.top/2018/07/18/proxy/","excerpt":"代理模式的定义 代理模式是为其他对象提供一种代理，使其可以控制对这个对象的访问，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 代理模式的优点，职责清晰，代理对象可以在客户端和目标对象起到中介的作用，代理对象保护了目标对象防止直接暴露给客户端，代理对象还可以扩展目标对象的功能","text":"代理模式的定义 代理模式是为其他对象提供一种代理，使其可以控制对这个对象的访问，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 代理模式的优点，职责清晰，代理对象可以在客户端和目标对象起到中介的作用，代理对象保护了目标对象防止直接暴露给客户端，代理对象还可以扩展目标对象的功能 代理相关角色创建 创建抽象角色 123456789/** * @author WXY * 抽象角色--接口 */public interface IUserDao &#123; void save();&#125; 创建代理的目标对象 1234567891011/** * @author WXY * 接口实现--目标对象 */public class UserImpl implements IUserDao &#123; @Override public void save() &#123; System.out.println(\"------------------user save---------------\"); &#125;&#125; 静态代理 静态代理需要实现抽象角色的接口，实现与目标对象相同的方法，再通过set方法注入目标对象，进而扩展目标对象的功能，如： 123456789101112131415161718/** * @author WXY * 代理对象--静态代理 */public class UserProxy implements IUserDao&#123; private IUserDao userDao; public UserProxy(IUserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; System.out.println(\"-------------start-----------\"); userDao.save(); System.out.println(\"---------------end--------------\"); &#125;&#125; 使用静态代理： 123IUserDao userDao = new UserImpl();UserProxy userProxy = new UserProxy(userDao);userProxy.save(); 静态代理需要代理类与被代理类要实现同一个接口，所以会出现大量的代码重复，每一种需要代理的对象都要实现不同的相对应的接口导致代码重用性低，使用繁琐。 JDK动态代理 JDK动态代理所用到的代理类在程序调用到代理类对象时才由JVM真正创建，JVM根据传进来的 业务实现类对象 以及 方法名 ，动态地创建了一个代理类的class文件并被字节码引擎执行，然后通过该代理类对象进行方法调用。 123456789101112131415161718192021222324/** * @author WXY * jdk-动态代理类 */public class ProxyFactory implements InvocationHandler &#123; private IUserDao userDao; public Object getInstance(IUserDao userDao)&#123; this.userDao = userDao; Class clazz = userDao.getClass(); System.out.println(\"道理对象是\"+clazz); return Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"-------------------------------\"); System.out.println(\"jdk动态代理\"); method.invoke(this.userDao,args); System.out.println(\"--------------------------------\"); return null; &#125;&#125; jdk代理使用： 12IUserDao user = (IUserDao) new ProxyFactory().getInstance(userDao);user.save(); JDK的动态代理是通过接口来进行强制转换的，生成以后的代理对象，可以强制转换为接口，被代理对象必须实现该接口 CGLib动态代理 CGLIB是一个强大的、高性能的代码生成库 ，CGLIB代理是针对类来实现代理的，原理是对指定的业务类生成一个子类，并覆盖其中业务方法实现代理。因为采用的是继承，所以不能对final修饰的类进行代理。 引入cglib包 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt;&lt;/dependency&gt; cglib代理工厂类 123456789101112131415161718192021222324252627282930/** * cglib代理 * @author WXY */public class CglibProxy implements MethodInterceptor &#123; /** * 获取代理对象 * @param clazz 代理对象 * @return 代理后对象 */ public static Object getInstance(Class clazz)&#123; // 使用cglib代理 Enhancer enhancer = new Enhancer(); //继承的代理类 enhancer.setSuperclass(clazz); //设置回调 enhancer.setCallback(new CglibProxy()); return enhancer.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"-------------执行之前-----------\"+method.getName()); //一定invokeSuper，调用invoke会出现死循环 Object object = methodProxy.invokeSuper(o,objects); System.out.println(\"--------------执行之后-------\"+method.getName()); return null; &#125;&#125; 代理使用： 12IUserDao proxyUserDao = (IUserDao)CglibProxy.getInstance(UserImpl.class);proxyUserDao.save(); CGLib的动态代理是通过生成一个被代理对象的子类，然后重写父类的方法，生成以后的对象，可以强制转换为被代理对象（也就是用自己写的类），子类引用赋值给父类","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wxiaoyang.top/categories/编程语言/"},{"name":"java","slug":"编程语言/java","permalink":"http://wxiaoyang.top/categories/编程语言/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://wxiaoyang.top/tags/设计模式/"}]},{"title":"Java Nio选择器Selector","slug":"selector","date":"2018-07-04T08:46:25.000Z","updated":"2018-07-05T06:55:02.448Z","comments":true,"path":"2018/07/04/selector/","link":"","permalink":"http://wxiaoyang.top/2018/07/04/selector/","excerpt":"Selector Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接 ，减少服务器的性能开销。","text":"Selector Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接 ，减少服务器的性能开销。 创建Selector 通过Selector 提供的静态方法创建 1Selector selector = Selector.open(); 通过SelectorProvider获取选择器 12SelectorProvider selectorProvider = SelectorProvider.provider();Selector selector = selectorProvider.openSelector(); 将通道注册到选择器上 通过ServerSocketChannel.register(Selector sel, int ops)方法注册的selecor中 12345678910//获取通道ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();//切换到非堵塞模式serverSocketChannel.configureBlocking(false);//绑定端口号serverSocketChannel.bind(new InetSocketAddress(8080));//获取选择器Selector selector = Selector.open();//将通道注册到选择器上，并且指定“监听接收事件”SelectionKey key = serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT); 与selector使用，channel必须处于非堵塞状态下，FileChannel无法切换到非堵塞状态下将不能与selector一起使用。 register()中的第二个参数表示通道监听的事件一共四种状态 SelectionKey.OP_CONNECT 连接 SelectionKey.OP_ACCEPT 接收 SelectionKey.OP_READ 读 SelectionKey.OP_WRITE 写 单一个通道监听多种事件时使用位或多种事件如： SelectionKey.OP_CONNECT|SelectionKey.OP_ACCEPT Selector的select()方法 Selector中注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回通道的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。 下面是select()方法： int select() int select(long timeout) int selectNow() select()阻塞到至少有一个通道在你注册的事件上就绪了。 select(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)。 selectNow()不会阻塞，不管什么通道就绪都立刻返回（此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。）。 select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。 selectedKeys()一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“选择健（已就绪的监听事件）”中的就绪通道。如下所示： 1Set selectedKeys = selector.selectedKeys() 使用Selector实现非堵塞Socket 服务端 123456789101112131415161718192021222324252627282930313233343536373839404142//1.获取通道ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();//2.切换到非堵塞模式serverSocketChannel.configureBlocking(false);//3.绑定端口号serverSocketChannel.bind(new InetSocketAddress(8080));//4.获取选择器Selector selector = Selector.open();//5.将通道注册到选择器上，并且指定“监听接收事件”serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);//6轮询式的获取选择器上已经‘准备就绪’的事件while (selector.select()&gt;0)&#123; //7 。获取当前选择器中所有注册的\"选择健（已就绪的监听事件）\" Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); while (iterator.hasNext())&#123; //8.获取“准备就绪”的事件 SelectionKey selectionKey = iterator.next(); //9.判断具体事件，就绪 if (selectionKey.isAcceptable())&#123; //10.接收就绪，获取客户端连接 SocketChannel socketChannel = serverSocketChannel.accept(); //11,切换到非堵塞模式 socketChannel.configureBlocking(false); //12.将客户端通道注册到选择器上 socketChannel.register(selector,SelectionKey.OP_READ); &#125;else if (selectionKey.isReadable())&#123; //获取当前选择器上“读就绪”状态的通道 SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); //读取客户端传过来的数据 int len = 0; while ((len = socketChannel.read(buffer))&gt;0)&#123; buffer.flip(); System.out.println(new String(buffer.array(),0,len)); buffer.clear(); &#125; &#125; //取消选择键selectionKey iterator.remove(); &#125;&#125; 客户端 1234567891011121314151617//1.获取通道SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\",8080));//2.设置为非堵塞模式socketChannel.configureBlocking(false);ByteBuffer buf = ByteBuffer.allocate(1024);//3.发送数据给服务端//控制台输入数据Scanner scanner = new Scanner(System.in);while (scanner.hasNext())&#123; String msg = scanner.next(); buf.put(msg.getBytes()); buf.flip(); socketChannel.write(buf); buf.clear();&#125;//4.关闭连接socketChannel.close(); 更多示例代码 本文参考","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wxiaoyang.top/categories/编程语言/"},{"name":"java","slug":"编程语言/java","permalink":"http://wxiaoyang.top/categories/编程语言/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"nio","slug":"nio","permalink":"http://wxiaoyang.top/tags/nio/"}]},{"title":"spring-webflux简介与示例","slug":"webflux","date":"2018-06-16T03:28:25.000Z","updated":"2018-06-16T03:36:09.230Z","comments":true,"path":"2018/06/16/webflux/","link":"","permalink":"http://wxiaoyang.top/2018/06/16/webflux/","excerpt":"简介 Spring WebFlux是Spring Framework 5.0中引入的新的反应式Web框架。与Spring MVC不同，它不需要Servlet API，完全异步和非阻塞，并通过Reactor项目实现Reactive Streams规范。并且可以在诸如Netty，Undertow和Servlet 3.1+容器的服务器上运行。","text":"简介 Spring WebFlux是Spring Framework 5.0中引入的新的反应式Web框架。与Spring MVC不同，它不需要Servlet API，完全异步和非阻塞，并通过Reactor项目实现Reactive Streams规范。并且可以在诸如Netty，Undertow和Servlet 3.1+容器的服务器上运行。 Reactor中的Mono和Flux Flux 和 Mono 是 Reactor 中的两个基本概念。Flux 表示的是包含 0 到 N 个元素的异步序列。在该序列中可以包含三种不同类型的消息通知：正常的包含元素的消息、序列结束的消息和序列出错的消息。当消息通知产生时，订阅者中对应的方法 onNext(), onComplete()和 onError()会被调用。Mono 表示的是包含 0 或者 1 个元素的异步序列。该序列中同样可以包含与 Flux 相同的三种类型的消息通知。Flux 和 Mono 之间可以进行转换。对一个 Flux 序列进行计数操作，得到的结果是一个 Mono对象。把两个 Mono 序列合并在一起，得到的是一个 Flux 对象。 了解更多 WebFlux的使用方式 如图所示，WebFlux支持两种编程方式 基于SpringMvc注解@Controller 基于Java8 lambda样式路由和处理 使用WebFlux需要单独引用它的依赖,我使用的springboot,依赖如下： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--reactor的测试依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 示例 基于SpringMvc注解 与使用SpringMvc不同的是使用SpringWebFlux同一使用Mono&lt;&gt;,Flux&lt;&gt;对象同意返回数据，如下 1234567891011121314151617181920212223242526@RestController@RequestMapping(\"/api/user\")public class WebFluxController &#123; private Map&lt;Long,User&gt; map = new HashMap&lt;Long,User&gt;(10); @PostConstruct public void init()&#123; map.put(1L,new User(1,\"admin\",\"admin\")); map.put(2L,new User(1,\"admin2\",\"admin2\")); map.put(3L,new User(1,\"admin3\",\"admin3\")); &#125; @GetMapping(\"/getAll\") public Flux&lt;User&gt; getAllUser()&#123; return Flux.fromIterable(map.entrySet().stream().map(Map.Entry::getValue) .collect(Collectors.toList())); &#125; @GetMapping(\"/&#123;id&#125;\") public Mono&lt;User&gt; getUserById(@PathVariable(\"id\") Long id)&#123; return Mono.just(map.get(id)); &#125; @PostMapping(\"/save\") public Mono&lt;ResponseEntity&lt;String&gt;&gt; save(@RequestBody User user)&#123; map.put(user.getUid(),user); return Mono.just(new ResponseEntity&lt;&gt;(\"添加成功\", HttpStatus.CREATED)); &#125;&#125; 具体实现代码可查看springboot-webflux 基于功能 处理请求的类，实现具体的业务逻辑，接口 ServerRequest 表示的是一个 HTTP 请求体。通过ServerRequest 对象可获取到请求的相关信息，如请求路径、查询参数和请求内容等。方法 的返回值是一个 Mono对象。接口 ServerResponse 用来表示 HTTP 响应。ServerResponse 中包含了很多静态方法来创建不同 HTTP 状态码的响应对象 123456789101112131415161718192021222324252627@Componentpublic class UserHandler &#123; private IUserService userService; @Autowired public UserHandler(IUserService userService) &#123; this.userService = userService; &#125; public Mono&lt;ServerResponse&gt; getAllUser(ServerRequest serverRequest)&#123; Flux&lt;User&gt; allUser = userService.getAllUser(); return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(allUser,User.class); &#125; public Mono&lt;ServerResponse&gt; getUserById(ServerRequest serverRequest)&#123; //获取url上的id Long uid = Long.valueOf(serverRequest.pathVariable(\"id\")); Mono&lt;User&gt; user = userService.getUserById(uid); return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(user,User.class); &#125; public Mono&lt;ServerResponse&gt; saveUser(ServerRequest serverRequest)&#123; Mono&lt;User&gt; user = serverRequest.bodyToMono(User.class); return ServerResponse.ok().build(userService.saveUser(user)); &#125;&#125; 为Handler类添加路由信息， 123456789101112@Configurationpublic class RoutingConfiguration &#123; @Bean public RouterFunction&lt;ServerResponse&gt; monoRouterFunction(UserHandler userHandler)&#123; return route(GET(\"/api/user\").and(accept(MediaType.APPLICATION_JSON)),userHandler::getAllUser) .andRoute(GET(\"/api/user/&#123;id&#125;\").and(accept(MediaType.APPLICATION_JSON)),userHandler::getUserById) .andRoute(POST(\"/api/save\").and(accept(MediaType.APPLICATION_JSON)),userHandler::saveUser); &#125;&#125; 具体实现代码可查看springboot-webflux-functional","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wxiaoyang.top/categories/编程语言/"},{"name":"java","slug":"编程语言/java","permalink":"http://wxiaoyang.top/categories/编程语言/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://wxiaoyang.top/tags/springboot/"},{"name":"webflux","slug":"webflux","permalink":"http://wxiaoyang.top/tags/webflux/"}]},{"title":"Java Nio中的缓冲区与通道","slug":"Java-nio","date":"2018-05-30T12:46:25.000Z","updated":"2018-06-05T13:52:20.269Z","comments":true,"path":"2018/05/30/Java-nio/","link":"","permalink":"http://wxiaoyang.top/2018/05/30/Java-nio/","excerpt":"Java NIO简介 Java NIO（New IO）是用于Java（来自Java 1.4）的替代IO API，意味着替代标准 Java IO和Java Networking API，Java NIO提供了与原来IO API不同的工作方式，但是作用和目的是一样的。NIO支持面向缓冲区的，基于通道的IO操作，NIO将以更加高效的方式进行文件的读写操作。","text":"Java NIO简介 Java NIO（New IO）是用于Java（来自Java 1.4）的替代IO API，意味着替代标准 Java IO和Java Networking API，Java NIO提供了与原来IO API不同的工作方式，但是作用和目的是一样的。NIO支持面向缓冲区的，基于通道的IO操作，NIO将以更加高效的方式进行文件的读写操作。 Java NIO与普通IO的主要区别 io nio 面向流 面向缓冲区（buffer，channel） 堵塞io 非堵塞io - 选择器 java nio主要的核心组件 缓冲区 buffer 通道 Channels 选择器 Selectors java nio缓冲区buffer 简介 Buffer是数据的容器，在nio中负责数据的存取，java为不同数据类型提供了相对应的缓冲区类型 如：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer 、DoubleBuffer 等。 Buffer的基本使用 通过allocate()方法获取缓冲区，put()方法存入数据到缓冲区，get()方法获取缓冲区中的数据 123456789101112String temp = \"abcdefg\";//通过allocate()方法获取指定大小的缓冲区ByteBuffer byteBuffer = ByteBuffer.allocate(1024);//使用put()方法将数据添加到缓冲区byteBuffer.put(temp.getBytes());//缓冲区切换读取数据模式byteBuffer.flip();//获取缓冲区数据byte[] dst = new byte[byteBuffer.limit()];//使用get()方法获取数据到dst中byteBuffer.get(dst);System.out.println(new String(dst,0,dst.length)); Buffer的核心属性 capacity:容量，表示缓冲区中最大存储数据的容量，一旦声明不能改变。 limit:界限，表示缓冲区中可以操作数据的大小。（limit后数据不能进行读写） position:位置，表示缓冲区中正在操作数据的位置 mark: 标记，表示记录当前position的位置，可通过reset()恢复到mark的位置 mark &lt;= position &lt;= limit &lt;= capacity，属性的各种状态的值可查看TestBuffer.java中的测试代码 直接缓冲区与非直接缓冲区 非直接缓冲区：通过allocate()分配缓冲区，缓冲区建立在jvm中。 直接缓冲区：通过allocateDirect()方法创建缓冲区，缓冲区建立在系统物理内存中。 java nio通道channel 简介 通道（channel）：用户数 据源节点和目标节点的连接。在Java nio中负责缓冲区中的数据传输， channel本身不存储数据，因此需要配合缓冲区进行传输,实现java.nio.channels.Channel接口 ，主要实现类有FileChannel、SocketChannel、ServerSocketChannel、DatagramChannel等。 获取通的方式 (1)java针对支持通道的类提供getChannel()方法本地IO有：FileInputStream/FileOutputStream、RandomAccessFile， 网络IO有：Socket、ServerSocket、DatagramSocket (2)在Java1.7中的NIO.2针对各个通道提供了静态方法open() (3)在Java1.7中的NIO.2的Files工具类的newByteChannel() 简单示例 12345678910111213141516171819202122//使用非直接缓冲区FileInputStream fis = new FileInputStream(\"chao.png\");FileOutputStream fos = new FileOutputStream(\"chao2.png\");//1.获取通道FileChannel inChannel = fis.getChannel();FileChannel outChannel = fos.getChannel();//2.分配指定大小缓冲区ByteBuffer buffer = ByteBuffer.allocate(3072);//3.将通道的数据存入缓冲区while (inChannel.read(buffer)!=-1)&#123; //缓冲区切换为读模式 buffer.flip(); //4.将缓冲区数据写入通道 outChannel.write(buffer); buffer.clear();&#125;outChannel.close();inChannel.close();fis.close();fos.close(); 更多示例代码可查阅官方api文档","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wxiaoyang.top/categories/编程语言/"},{"name":"java","slug":"编程语言/java","permalink":"http://wxiaoyang.top/categories/编程语言/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"nio","slug":"nio","permalink":"http://wxiaoyang.top/tags/nio/"}]},{"title":"Spring Cloud Sleuth和zipkin微服务跟踪","slug":"zipkin","date":"2018-04-22T08:08:25.000Z","updated":"2018-07-20T02:44:35.331Z","comments":true,"path":"2018/04/22/zipkin/","link":"","permalink":"http://wxiaoyang.top/2018/04/22/zipkin/","excerpt":"Spring Cloud Sleuth： Spring Cloud Sleuth是为Spring Cloud实现了分布式追踪解决方案，Spring Cloud Sleuth借用了Dapper的术语： 跨度（Span）：基本的工作单位。例如，发送一个RPC是一个新的跨度，就像向RPC发送响应一样。跨度由跨度的唯一64位ID和跨度所包含的另一个 64位ID标识。Spans还具有其他数据，例如描述，时间戳事件，键值注释（标记），导致它们的跨度的ID以及进程ID（通常为IP地址）。跨度启动和停止，并跟踪他们的时间信息。一旦你创建了一个跨度，你必须在将来某个时候停止它。开始追踪的初始跨度被称为 root span。该跨度的span id的值等于trace id 痕迹（Trace）：一组形成树状结构的跨度。例如，如果您正在运行分布式大数据存储，则跟踪可能由放入请求组成。","text":"Spring Cloud Sleuth： Spring Cloud Sleuth是为Spring Cloud实现了分布式追踪解决方案，Spring Cloud Sleuth借用了Dapper的术语： 跨度（Span）：基本的工作单位。例如，发送一个RPC是一个新的跨度，就像向RPC发送响应一样。跨度由跨度的唯一64位ID和跨度所包含的另一个 64位ID标识。Spans还具有其他数据，例如描述，时间戳事件，键值注释（标记），导致它们的跨度的ID以及进程ID（通常为IP地址）。跨度启动和停止，并跟踪他们的时间信息。一旦你创建了一个跨度，你必须在将来某个时候停止它。开始追踪的初始跨度被称为 root span。该跨度的span id的值等于trace id 痕迹（Trace）：一组形成树状结构的跨度。例如，如果您正在运行分布式大数据存储，则跟踪可能由放入请求组成。 标注（Annotation）：用于及时记录事件的存在。用于定义请求开始和结束的一些核心注释是 cs - 客户端发送 - 客户端发出请求。这个注释描述了跨度的开始。 sr - 服务器已收到 - 服务器端收到请求并开始处理。如果从这个时间戳中减去cs时间戳，将会收到网络延迟。 ss - 服务器发送 - 在请求处理完成时（当响应被发送回客户端时）注释。如果从这个时间戳中减去sr时间戳，将会收到服务器端处理请求所需的时间。 cr - 客户端收到 - 表示跨度结束。客户端已经成功接收到服务器端的响应。如果从这个时间戳中减去cs时间戳，那么将会收到客户端接收服务器响应所需的全部时间。 Span和Trace在系统中与Zipkin Annotation一起显示的可视化示例： Zipkin Zipkin是一个分布式追踪系统。它有助于收集解决微服务架构中延迟问题所需的时序数据。它管理这些数据的收集和查找。 应用程序用于向Zipkin报告时间数据。Zipkin UI还提供了一个依赖关系图，显示每个应用程序有多少跟踪请求。如果你正在解决延迟问题或错误问题，则可以根据应用程序，跟踪长度，注释或时间戳过滤或排序所有跟踪。一旦选择了一个跟踪，你可以看到每个跨度所花费的总跟踪时间的百分比，从而可以确定问题应用程序。 在SpringCloud中使用Zipkin： springcloud创建zipkin-server,依赖除了springcloud的基础依赖外再添加zipkin依赖，如下 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt; &lt;/dependency&gt; 启动类添加标签@EnableZipkinServer启动zipkin，代码如下 123456789101112/** * @author wxy */ @SpringBootApplication @EnableZipkinServer @EnableEurekaClient public class ZipKinServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZipKinServerApplication.class, args); &#125; &#125; 配置文件，如下 123456789101112spring: application: name: micoserice-zipkin-server server: port: 9994 eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ instance: instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; prefer-ip-address: true 启动后可直接访问localhost:9994，可看到zipkin的页面 ​ 除了这种方式还可通过docker安装，可查看教程https://github.com/openzipkin/zipkin 为微服务提供者消费者添加zipkin依赖和配置 ​ 添加依赖 12345&lt;!-- zipkin依赖jar--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; 添加配置 123456spring: zipkin: base-url: http://localhost:9994 sleuth: sampler: percentage: 1.0 spring.sleuth.sampler.percentage 是监控的百分比，默认的是0.1表示10%,这里给1.0表示全部监控spring.zipkin.base-url是zipkin-server的服务路径 依次启动服务如下 ​ ​ 我这里启动了zuul,ribbon以及user服务，通过zuul网管依次访问ribbon和user，查看zipkin如下图： ​ 示例代码：microservice-sleuth-zipkin-server 参考文档 http://cloud.spring.io/spring-cloud-static/Edgware.SR1/multi/multi__introduction.html ​ http://www.ityouknow.com/springcloud/2018/02/02/spring-cloud-sleuth-zipkin.html ​ https://zipkin.io/","categories":[{"name":"microservice","slug":"microservice","permalink":"http://wxiaoyang.top/categories/microservice/"},{"name":"springcloud","slug":"microservice/springcloud","permalink":"http://wxiaoyang.top/categories/microservice/springcloud/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://wxiaoyang.top/tags/springcloud/"},{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://wxiaoyang.top/tags/springboot/"},{"name":"zipkin","slug":"zipkin","permalink":"http://wxiaoyang.top/tags/zipkin/"}]},{"title":"Spring Cloud网关zuul","slug":"zuul","date":"2018-01-11T07:32:25.000Z","updated":"2018-07-20T02:34:24.316Z","comments":true,"path":"2018/01/11/zuul/","link":"","permalink":"http://wxiaoyang.top/2018/01/11/zuul/","excerpt":"Zuul 简介 “Zuul is the front door for all requests from devices and web sites to the backend of the Netflix streaming application. As an edge service application, Zuul is built to enable dynamic routing, monitoring, resiliency and security. It also has the ability to route requests to multiple Amazon Auto Scaling Groups as appropriate.” 大致是说zuul是设备和网站到Netflix后台应用程序的所有的请求的前门，是一个边缘化应用程序，它的创建是为了实现动态路由，监控，弹性，和安全性， 它还能够根据需要将请求路由到多个Amazon Auto Scaling组。","text":"Zuul 简介 “Zuul is the front door for all requests from devices and web sites to the backend of the Netflix streaming application. As an edge service application, Zuul is built to enable dynamic routing, monitoring, resiliency and security. It also has the ability to route requests to multiple Amazon Auto Scaling Groups as appropriate.” 大致是说zuul是设备和网站到Netflix后台应用程序的所有的请求的前门，是一个边缘化应用程序，它的创建是为了实现动态路由，监控，弹性，和安全性， 它还能够根据需要将请求路由到多个Amazon Auto Scaling组。 来源’https://github.com/Netflix/zuul/wiki‘ zuul主要实现的功能就是API Gateway(api网关)的功能 为什么使用api gateway: 客户端会多次请求不同的微服务，导致客户端复杂度增加，使用网关时客户端只与网关交互，降低客户端的调用逻辑的复杂度，同时网关也可以实现认证逻辑简化内部服务的之间相互调用的复杂度。 对不同客户端的支持及数据的聚合，如一个网站有web端，手机端，页面所需的数据有同有异，可以将数据整合或者裁剪，减少客户端的请求次数，比如BFF架构。 可以更好的对项目的微服务封装，可将项目的微服务统一封装在一个内网环境中，只通过网关提供服务，同时网关也可以对安全，认证，监控，防御单独强化。 在springcloud使用zuul： ​ 1、除了添加eureka依赖外，添加zuul依赖包：123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;&lt;/dependency&gt; ​ 2、在启动类上使用@EnableZuulProxy 启用zuul 12345678910111213@SpringBootApplication@EnableZuulProxypublic class ZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplication.class, args); &#125;&#125; ​ 3、配置文件application.yml1234567891011121314spring: application: name: micoserice-gateway-zuulserver: port: 8090eureka: client: serviceUrl: defaultZone: &lt;http://localhost:8761/eureka/&gt; instance: prefer-ip-address: true instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 启动运行： 如图我这里启动了三个服务，zuul注册到Eureka-service为服务后默认情况下是构建PAI-GATEWAY，访问时只要zuul-host/appname/api 如我这里访问：http://localhost:8090/micoserice-user/user/getuser，当调用服务有多个时，zuul是实现了负载均衡的。 zuul中使用hystrix的回退 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*** @author wxy* zuul中使用hystrix的回退*/@Componentpublic class MyFallbackProvider implements ZuulFallbackProvider &#123; @Override public String getRoute() &#123; //路由配置micoserice-user，如果全部用\"*\"代替 return \"micoserice-user\"; &#125; @Override public ClientHttpResponse fallbackResponse() &#123; return new ClientHttpResponse() &#123; @Override public HttpStatus getStatusCode() throws IOException &#123; //回退的状态码 return HttpStatus.OK; &#125; @Override public int getRawStatusCode() throws IOException &#123; //数字类型状态码 return 200; &#125; @Override public String getStatusText() throws IOException &#123; //状态文本 return \"ok\"; &#125; @Override public void close() &#123; &#125; @Override public InputStream getBody() throws IOException &#123; //回退响应体 return new ByteArrayInputStream(\"服务不可用稍后再试\".getBytes()); &#125; @Override public HttpHeaders getHeaders() &#123; //header设置 HttpHeaders headers = new HttpHeaders(); MediaType mediaType = new MediaType(\"application\",\"json\", Charset.forName(\"UTF-8\")); headers.setContentType(mediaType); return headers; &#125; &#125;; &#125;&#125; 添加回退后当访问micoserice-user 微服务失败后将会返回“服务不可用稍后再试”。 zuul过滤器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*** @author wxy* zuul过滤器* zuul中定义了四种标准过滤类型，这些过滤类型对应请求的生命周期** PRE:这种过滤类型在请求被路由之前调用。可利用这种过滤器实现身份验证，在集群中选择请求的微服务，记录调试信息等。** ROUTING:这种过滤器将请求路由到微服务。这种过滤用于构建发送给微服务的请求，* 并可以使用Apache HttpClient,Fegin,Ribbon请求微服务。** POST:这种过滤器在路由到微服务以后执行。这种过滤器可用来微响应添加标准的http header,* 搜集统计信息和指标，将响应发送给客户端。** ERROR:在其他阶段发生错误时执行该过滤器。**/public class RequestLogFilter extends ZuulFilter &#123; private static Logger logger = LoggerFactory.getLogger(RequestLogFilter.class); @Override public String filterType() &#123; return PRE_TYPE; &#125; @Override public int filterOrder() &#123; return 1; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; RequestContext requestContext =RequestContext.getCurrentContext(); HttpServletRequest request = requestContext.getRequest(); logger.info(String.format(\"send %s request to %s\",request.getMethod(),request.getRequestURL().toString())); return null; &#125;&#125;//在启动类下添加Bean@Beanpublic RequestLogFilter getRequestLogFilter()&#123;return new RequestLogFilter();&#125; 示例代码：microservice-gateway-zuul本文参考http://cloud.spring.io/spring-cloud-static/Finchley.M2/#_router_and_filter_zuulhttp://www.ityouknow.com/springcloud/2017/06/01/gateway-service-zuul.html http://microservices.io/patterns/apigateway.html","categories":[{"name":"microservice","slug":"microservice","permalink":"http://wxiaoyang.top/categories/microservice/"},{"name":"springcloud","slug":"microservice/springcloud","permalink":"http://wxiaoyang.top/categories/microservice/springcloud/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://wxiaoyang.top/tags/springcloud/"},{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://wxiaoyang.top/tags/springboot/"},{"name":"zuul","slug":"zuul","permalink":"http://wxiaoyang.top/tags/zuul/"}]}]}