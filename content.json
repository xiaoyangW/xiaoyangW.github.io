{"meta":{"title":"晓阳","subtitle":null,"description":null,"author":"John Doe","url":"http://wxiaoyang.top"},"pages":[{"title":"Categories","date":"2018-06-03T11:01:03.315Z","updated":"2018-06-03T11:01:03.315Z","comments":true,"path":"categories/index.html","permalink":"http://wxiaoyang.top/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-06-03T11:01:03.313Z","updated":"2018-06-03T11:01:03.313Z","comments":true,"path":"about/index.html","permalink":"http://wxiaoyang.top/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-06-03T11:01:03.317Z","updated":"2018-06-03T11:01:03.317Z","comments":true,"path":"tags/index.html","permalink":"http://wxiaoyang.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"zookeeper集群安装","slug":"zk-install","date":"2018-09-25T16:00:00.000Z","updated":"2018-10-22T10:37:15.373Z","comments":true,"path":"2018/09/26/zk-install/","link":"","permalink":"http://wxiaoyang.top/2018/09/26/zk-install/","excerpt":"环境准备 zookeeper安装包：http://www-eu.apache.org/dist/zookeeper/stable/zookeeper-3.4.12.tar.gz centos + java 运行环境，这里我分别准备三台centos虚拟机192.168.146.151，192.168.146.152，192.168.146.153","text":"环境准备 zookeeper安装包：http://www-eu.apache.org/dist/zookeeper/stable/zookeeper-3.4.12.tar.gz centos + java 运行环境，这里我分别准备三台centos虚拟机192.168.146.151，192.168.146.152，192.168.146.153 安装配置 解压zookeeper安装包，tar -zxvf zookeeper-3.4.12.tar.gz ,解压后目录 添加zookeeper配置，进入conf目录，使用cp zoo_sample.cfg zoo.cfg 复制zoo_sample.cfg为zoo.cfg 修改后配置 12345678910111213141516171819202122232425262728293031# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial # synchronization phase can takeinitLimit=10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just # example sakes.dataDir=/tmp/zookeeper# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1server.1=192.168.146.151:2188:3181server.2=192.168.146.152:2188:3181server.3=192.168.146.153:2188:3181 主要配置说明 ​ clientPort运行端口号 ​ dataDir数据存储位置 myid设置 ​ 当安装zookeeper集群环境时要在dataDir目录下创建当前zookeeper的myid ​ 如我在192.168.146.151机器上创建在/tmp/zookeeper/myid文件，文件内容为1，依次类推 。 添加server集群配置 ​ server.1=192.168.146.151:2188:3181–&gt;server.myid=ip:clientPort:prot，有几台机器添加几条配置 ，注意两个端口号不可以重复（如果重复会出现端口号重复的问题）,如上配置。 启动运行，进入每台机器zookeeper目录中的bin文件夹，运行zkServer.sh脚本，如 sh zkServer.sh start ,运行时可在启动目录下查看zookeeper.out 控制台日志。 启动好了可通过运行bin目录下的zkCli.sh脚本连接zookeeper，如 也可通过sh zkServer.sh status 查看当前zookeeper是什么角色 注：zookeeper 集群角色分为leader、follower、observer，这里我配置的只有leader和follower，要台添加一台observer机器，在server配置后面标记为observer如：server.4=192.168.146.154:2188:3181:observer","categories":[{"name":"microservice","slug":"microservice","permalink":"http://wxiaoyang.top/categories/microservice/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://wxiaoyang.top/tags/linux/"}]},{"title":"Java 代理模式","slug":"proxy","date":"2018-07-18T08:46:25.000Z","updated":"2018-07-19T13:39:22.619Z","comments":true,"path":"2018/07/18/proxy/","link":"","permalink":"http://wxiaoyang.top/2018/07/18/proxy/","excerpt":"代理模式的定义 代理模式是为其他对象提供一种代理，使其可以控制对这个对象的访问，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 代理模式的优点，职责清晰，代理对象可以在客户端和目标对象起到中介的作用，代理对象保护了目标对象防止直接暴露给客户端，代理对象还可以扩展目标对象的功能","text":"代理模式的定义 代理模式是为其他对象提供一种代理，使其可以控制对这个对象的访问，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 代理模式的优点，职责清晰，代理对象可以在客户端和目标对象起到中介的作用，代理对象保护了目标对象防止直接暴露给客户端，代理对象还可以扩展目标对象的功能 代理相关角色创建 创建抽象角色 123456789/** * @author WXY * 抽象角色--接口 */public interface IUserDao &#123; void save();&#125; 创建代理的目标对象 1234567891011/** * @author WXY * 接口实现--目标对象 */public class UserImpl implements IUserDao &#123; @Override public void save() &#123; System.out.println(\"------------------user save---------------\"); &#125;&#125; 静态代理 静态代理需要实现抽象角色的接口，实现与目标对象相同的方法，再通过set方法注入目标对象，进而扩展目标对象的功能，如： 123456789101112131415161718/** * @author WXY * 代理对象--静态代理 */public class UserProxy implements IUserDao&#123; private IUserDao userDao; public UserProxy(IUserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; System.out.println(\"-------------start-----------\"); userDao.save(); System.out.println(\"---------------end--------------\"); &#125;&#125; 使用静态代理： 123IUserDao userDao = new UserImpl();UserProxy userProxy = new UserProxy(userDao);userProxy.save(); 静态代理需要代理类与被代理类要实现同一个接口，所以会出现大量的代码重复，每一种需要代理的对象都要实现不同的相对应的接口导致代码重用性低，使用繁琐。 JDK动态代理 JDK动态代理所用到的代理类在程序调用到代理类对象时才由JVM真正创建，JVM根据传进来的 业务实现类对象 以及 方法名 ，动态地创建了一个代理类的class文件并被字节码引擎执行，然后通过该代理类对象进行方法调用。 123456789101112131415161718192021222324/** * @author WXY * jdk-动态代理类 */public class ProxyFactory implements InvocationHandler &#123; private IUserDao userDao; public Object getInstance(IUserDao userDao)&#123; this.userDao = userDao; Class clazz = userDao.getClass(); System.out.println(\"道理对象是\"+clazz); return Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"-------------------------------\"); System.out.println(\"jdk动态代理\"); method.invoke(this.userDao,args); System.out.println(\"--------------------------------\"); return null; &#125;&#125; jdk代理使用： 12IUserDao user = (IUserDao) new ProxyFactory().getInstance(userDao);user.save(); JDK的动态代理是通过接口来进行强制转换的，生成以后的代理对象，可以强制转换为接口，被代理对象必须实现该接口 CGLib动态代理 CGLIB是一个强大的、高性能的代码生成库 ，CGLIB代理是针对类来实现代理的，原理是对指定的业务类生成一个子类，并覆盖其中业务方法实现代理。因为采用的是继承，所以不能对final修饰的类进行代理。 引入cglib包 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt;&lt;/dependency&gt; cglib代理工厂类 123456789101112131415161718192021222324252627282930/** * cglib代理 * @author WXY */public class CglibProxy implements MethodInterceptor &#123; /** * 获取代理对象 * @param clazz 代理对象 * @return 代理后对象 */ public static Object getInstance(Class clazz)&#123; // 使用cglib代理 Enhancer enhancer = new Enhancer(); //继承的代理类 enhancer.setSuperclass(clazz); //设置回调 enhancer.setCallback(new CglibProxy()); return enhancer.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"-------------执行之前-----------\"+method.getName()); //一定invokeSuper，调用invoke会出现死循环 Object object = methodProxy.invokeSuper(o,objects); System.out.println(\"--------------执行之后-------\"+method.getName()); return null; &#125;&#125; 代理使用： 12IUserDao proxyUserDao = (IUserDao)CglibProxy.getInstance(UserImpl.class);proxyUserDao.save(); CGLib的动态代理是通过生成一个被代理对象的子类，然后重写父类的方法，生成以后的对象，可以强制转换为被代理对象（也就是用自己写的类），子类引用赋值给父类","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wxiaoyang.top/categories/编程语言/"},{"name":"java","slug":"编程语言/java","permalink":"http://wxiaoyang.top/categories/编程语言/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://wxiaoyang.top/tags/设计模式/"}]},{"title":"Java Nio选择器Selector","slug":"selector","date":"2018-07-04T08:46:25.000Z","updated":"2018-07-05T06:55:02.448Z","comments":true,"path":"2018/07/04/selector/","link":"","permalink":"http://wxiaoyang.top/2018/07/04/selector/","excerpt":"Selector Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接 ，减少服务器的性能开销。","text":"Selector Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接 ，减少服务器的性能开销。 创建Selector 通过Selector 提供的静态方法创建 1Selector selector = Selector.open(); 通过SelectorProvider获取选择器 12SelectorProvider selectorProvider = SelectorProvider.provider();Selector selector = selectorProvider.openSelector(); 将通道注册到选择器上 通过ServerSocketChannel.register(Selector sel, int ops)方法注册的selecor中 12345678910//获取通道ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();//切换到非堵塞模式serverSocketChannel.configureBlocking(false);//绑定端口号serverSocketChannel.bind(new InetSocketAddress(8080));//获取选择器Selector selector = Selector.open();//将通道注册到选择器上，并且指定“监听接收事件”SelectionKey key = serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT); 与selector使用，channel必须处于非堵塞状态下，FileChannel无法切换到非堵塞状态下将不能与selector一起使用。 register()中的第二个参数表示通道监听的事件一共四种状态 SelectionKey.OP_CONNECT 连接 SelectionKey.OP_ACCEPT 接收 SelectionKey.OP_READ 读 SelectionKey.OP_WRITE 写 单一个通道监听多种事件时使用位或多种事件如： SelectionKey.OP_CONNECT|SelectionKey.OP_ACCEPT Selector的select()方法 Selector中注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回通道的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。 下面是select()方法： int select() int select(long timeout) int selectNow() select()阻塞到至少有一个通道在你注册的事件上就绪了。 select(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)。 selectNow()不会阻塞，不管什么通道就绪都立刻返回（此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。）。 select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。 selectedKeys()一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“选择健（已就绪的监听事件）”中的就绪通道。如下所示： 1Set selectedKeys = selector.selectedKeys() 使用Selector实现非堵塞Socket 服务端 123456789101112131415161718192021222324252627282930313233343536373839404142//1.获取通道ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();//2.切换到非堵塞模式serverSocketChannel.configureBlocking(false);//3.绑定端口号serverSocketChannel.bind(new InetSocketAddress(8080));//4.获取选择器Selector selector = Selector.open();//5.将通道注册到选择器上，并且指定“监听接收事件”serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);//6轮询式的获取选择器上已经‘准备就绪’的事件while (selector.select()&gt;0)&#123; //7 。获取当前选择器中所有注册的\"选择健（已就绪的监听事件）\" Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); while (iterator.hasNext())&#123; //8.获取“准备就绪”的事件 SelectionKey selectionKey = iterator.next(); //9.判断具体事件，就绪 if (selectionKey.isAcceptable())&#123; //10.接收就绪，获取客户端连接 SocketChannel socketChannel = serverSocketChannel.accept(); //11,切换到非堵塞模式 socketChannel.configureBlocking(false); //12.将客户端通道注册到选择器上 socketChannel.register(selector,SelectionKey.OP_READ); &#125;else if (selectionKey.isReadable())&#123; //获取当前选择器上“读就绪”状态的通道 SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); //读取客户端传过来的数据 int len = 0; while ((len = socketChannel.read(buffer))&gt;0)&#123; buffer.flip(); System.out.println(new String(buffer.array(),0,len)); buffer.clear(); &#125; &#125; //取消选择键selectionKey iterator.remove(); &#125;&#125; 客户端 1234567891011121314151617//1.获取通道SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\",8080));//2.设置为非堵塞模式socketChannel.configureBlocking(false);ByteBuffer buf = ByteBuffer.allocate(1024);//3.发送数据给服务端//控制台输入数据Scanner scanner = new Scanner(System.in);while (scanner.hasNext())&#123; String msg = scanner.next(); buf.put(msg.getBytes()); buf.flip(); socketChannel.write(buf); buf.clear();&#125;//4.关闭连接socketChannel.close(); 更多示例代码 本文参考","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wxiaoyang.top/categories/编程语言/"},{"name":"java","slug":"编程语言/java","permalink":"http://wxiaoyang.top/categories/编程语言/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"nio","slug":"nio","permalink":"http://wxiaoyang.top/tags/nio/"}]},{"title":"spring-webflux简介与示例","slug":"webflux","date":"2018-06-16T03:28:25.000Z","updated":"2018-06-16T03:36:09.230Z","comments":true,"path":"2018/06/16/webflux/","link":"","permalink":"http://wxiaoyang.top/2018/06/16/webflux/","excerpt":"简介 Spring WebFlux是Spring Framework 5.0中引入的新的反应式Web框架。与Spring MVC不同，它不需要Servlet API，完全异步和非阻塞，并通过Reactor项目实现Reactive Streams规范。并且可以在诸如Netty，Undertow和Servlet 3.1+容器的服务器上运行。","text":"简介 Spring WebFlux是Spring Framework 5.0中引入的新的反应式Web框架。与Spring MVC不同，它不需要Servlet API，完全异步和非阻塞，并通过Reactor项目实现Reactive Streams规范。并且可以在诸如Netty，Undertow和Servlet 3.1+容器的服务器上运行。 Reactor中的Mono和Flux Flux 和 Mono 是 Reactor 中的两个基本概念。Flux 表示的是包含 0 到 N 个元素的异步序列。在该序列中可以包含三种不同类型的消息通知：正常的包含元素的消息、序列结束的消息和序列出错的消息。当消息通知产生时，订阅者中对应的方法 onNext(), onComplete()和 onError()会被调用。Mono 表示的是包含 0 或者 1 个元素的异步序列。该序列中同样可以包含与 Flux 相同的三种类型的消息通知。Flux 和 Mono 之间可以进行转换。对一个 Flux 序列进行计数操作，得到的结果是一个 Mono对象。把两个 Mono 序列合并在一起，得到的是一个 Flux 对象。 了解更多 WebFlux的使用方式 如图所示，WebFlux支持两种编程方式 基于SpringMvc注解@Controller 基于Java8 lambda样式路由和处理 使用WebFlux需要单独引用它的依赖,我使用的springboot,依赖如下： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--reactor的测试依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 示例 基于SpringMvc注解 与使用SpringMvc不同的是使用SpringWebFlux同一使用Mono&lt;&gt;,Flux&lt;&gt;对象同意返回数据，如下 1234567891011121314151617181920212223242526@RestController@RequestMapping(\"/api/user\")public class WebFluxController &#123; private Map&lt;Long,User&gt; map = new HashMap&lt;Long,User&gt;(10); @PostConstruct public void init()&#123; map.put(1L,new User(1,\"admin\",\"admin\")); map.put(2L,new User(1,\"admin2\",\"admin2\")); map.put(3L,new User(1,\"admin3\",\"admin3\")); &#125; @GetMapping(\"/getAll\") public Flux&lt;User&gt; getAllUser()&#123; return Flux.fromIterable(map.entrySet().stream().map(Map.Entry::getValue) .collect(Collectors.toList())); &#125; @GetMapping(\"/&#123;id&#125;\") public Mono&lt;User&gt; getUserById(@PathVariable(\"id\") Long id)&#123; return Mono.just(map.get(id)); &#125; @PostMapping(\"/save\") public Mono&lt;ResponseEntity&lt;String&gt;&gt; save(@RequestBody User user)&#123; map.put(user.getUid(),user); return Mono.just(new ResponseEntity&lt;&gt;(\"添加成功\", HttpStatus.CREATED)); &#125;&#125; 具体实现代码可查看springboot-webflux 基于功能 处理请求的类，实现具体的业务逻辑，接口 ServerRequest 表示的是一个 HTTP 请求体。通过ServerRequest 对象可获取到请求的相关信息，如请求路径、查询参数和请求内容等。方法 的返回值是一个 Mono对象。接口 ServerResponse 用来表示 HTTP 响应。ServerResponse 中包含了很多静态方法来创建不同 HTTP 状态码的响应对象 123456789101112131415161718192021222324252627@Componentpublic class UserHandler &#123; private IUserService userService; @Autowired public UserHandler(IUserService userService) &#123; this.userService = userService; &#125; public Mono&lt;ServerResponse&gt; getAllUser(ServerRequest serverRequest)&#123; Flux&lt;User&gt; allUser = userService.getAllUser(); return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(allUser,User.class); &#125; public Mono&lt;ServerResponse&gt; getUserById(ServerRequest serverRequest)&#123; //获取url上的id Long uid = Long.valueOf(serverRequest.pathVariable(\"id\")); Mono&lt;User&gt; user = userService.getUserById(uid); return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(user,User.class); &#125; public Mono&lt;ServerResponse&gt; saveUser(ServerRequest serverRequest)&#123; Mono&lt;User&gt; user = serverRequest.bodyToMono(User.class); return ServerResponse.ok().build(userService.saveUser(user)); &#125;&#125; 为Handler类添加路由信息， 123456789101112@Configurationpublic class RoutingConfiguration &#123; @Bean public RouterFunction&lt;ServerResponse&gt; monoRouterFunction(UserHandler userHandler)&#123; return route(GET(\"/api/user\").and(accept(MediaType.APPLICATION_JSON)),userHandler::getAllUser) .andRoute(GET(\"/api/user/&#123;id&#125;\").and(accept(MediaType.APPLICATION_JSON)),userHandler::getUserById) .andRoute(POST(\"/api/save\").and(accept(MediaType.APPLICATION_JSON)),userHandler::saveUser); &#125;&#125; 具体实现代码可查看springboot-webflux-functional","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wxiaoyang.top/categories/编程语言/"},{"name":"java","slug":"编程语言/java","permalink":"http://wxiaoyang.top/categories/编程语言/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://wxiaoyang.top/tags/springboot/"},{"name":"webflux","slug":"webflux","permalink":"http://wxiaoyang.top/tags/webflux/"}]},{"title":"Java Nio中的缓冲区与通道","slug":"Java-nio","date":"2018-05-30T12:46:25.000Z","updated":"2018-06-05T13:52:20.269Z","comments":true,"path":"2018/05/30/Java-nio/","link":"","permalink":"http://wxiaoyang.top/2018/05/30/Java-nio/","excerpt":"Java NIO简介 Java NIO（New IO）是用于Java（来自Java 1.4）的替代IO API，意味着替代标准 Java IO和Java Networking API，Java NIO提供了与原来IO API不同的工作方式，但是作用和目的是一样的。NIO支持面向缓冲区的，基于通道的IO操作，NIO将以更加高效的方式进行文件的读写操作。","text":"Java NIO简介 Java NIO（New IO）是用于Java（来自Java 1.4）的替代IO API，意味着替代标准 Java IO和Java Networking API，Java NIO提供了与原来IO API不同的工作方式，但是作用和目的是一样的。NIO支持面向缓冲区的，基于通道的IO操作，NIO将以更加高效的方式进行文件的读写操作。 Java NIO与普通IO的主要区别 io nio 面向流 面向缓冲区（buffer，channel） 堵塞io 非堵塞io - 选择器 java nio主要的核心组件 缓冲区 buffer 通道 Channels 选择器 Selectors java nio缓冲区buffer 简介 Buffer是数据的容器，在nio中负责数据的存取，java为不同数据类型提供了相对应的缓冲区类型 如：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer 、DoubleBuffer 等。 Buffer的基本使用 通过allocate()方法获取缓冲区，put()方法存入数据到缓冲区，get()方法获取缓冲区中的数据 123456789101112String temp = \"abcdefg\";//通过allocate()方法获取指定大小的缓冲区ByteBuffer byteBuffer = ByteBuffer.allocate(1024);//使用put()方法将数据添加到缓冲区byteBuffer.put(temp.getBytes());//缓冲区切换读取数据模式byteBuffer.flip();//获取缓冲区数据byte[] dst = new byte[byteBuffer.limit()];//使用get()方法获取数据到dst中byteBuffer.get(dst);System.out.println(new String(dst,0,dst.length)); Buffer的核心属性 capacity:容量，表示缓冲区中最大存储数据的容量，一旦声明不能改变。 limit:界限，表示缓冲区中可以操作数据的大小。（limit后数据不能进行读写） position:位置，表示缓冲区中正在操作数据的位置 mark: 标记，表示记录当前position的位置，可通过reset()恢复到mark的位置 mark &lt;= position &lt;= limit &lt;= capacity，属性的各种状态的值可查看TestBuffer.java中的测试代码 直接缓冲区与非直接缓冲区 非直接缓冲区：通过allocate()分配缓冲区，缓冲区建立在jvm中。 直接缓冲区：通过allocateDirect()方法创建缓冲区，缓冲区建立在系统物理内存中。 java nio通道channel 简介 通道（channel）：用户数 据源节点和目标节点的连接。在Java nio中负责缓冲区中的数据传输， channel本身不存储数据，因此需要配合缓冲区进行传输,实现java.nio.channels.Channel接口 ，主要实现类有FileChannel、SocketChannel、ServerSocketChannel、DatagramChannel等。 获取通的方式 (1)java针对支持通道的类提供getChannel()方法本地IO有：FileInputStream/FileOutputStream、RandomAccessFile， 网络IO有：Socket、ServerSocket、DatagramSocket (2)在Java1.7中的NIO.2针对各个通道提供了静态方法open() (3)在Java1.7中的NIO.2的Files工具类的newByteChannel() 简单示例 12345678910111213141516171819202122//使用非直接缓冲区FileInputStream fis = new FileInputStream(\"chao.png\");FileOutputStream fos = new FileOutputStream(\"chao2.png\");//1.获取通道FileChannel inChannel = fis.getChannel();FileChannel outChannel = fos.getChannel();//2.分配指定大小缓冲区ByteBuffer buffer = ByteBuffer.allocate(3072);//3.将通道的数据存入缓冲区while (inChannel.read(buffer)!=-1)&#123; //缓冲区切换为读模式 buffer.flip(); //4.将缓冲区数据写入通道 outChannel.write(buffer); buffer.clear();&#125;outChannel.close();inChannel.close();fis.close();fos.close(); 更多示例代码可查阅官方api文档","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wxiaoyang.top/categories/编程语言/"},{"name":"java","slug":"编程语言/java","permalink":"http://wxiaoyang.top/categories/编程语言/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"nio","slug":"nio","permalink":"http://wxiaoyang.top/tags/nio/"}]},{"title":"Spring Cloud Sleuth和zipkin微服务跟踪","slug":"zipkin","date":"2018-04-22T08:08:25.000Z","updated":"2018-07-20T02:44:35.331Z","comments":true,"path":"2018/04/22/zipkin/","link":"","permalink":"http://wxiaoyang.top/2018/04/22/zipkin/","excerpt":"Spring Cloud Sleuth： Spring Cloud Sleuth是为Spring Cloud实现了分布式追踪解决方案，Spring Cloud Sleuth借用了Dapper的术语： 跨度（Span）：基本的工作单位。例如，发送一个RPC是一个新的跨度，就像向RPC发送响应一样。跨度由跨度的唯一64位ID和跨度所包含的另一个 64位ID标识。Spans还具有其他数据，例如描述，时间戳事件，键值注释（标记），导致它们的跨度的ID以及进程ID（通常为IP地址）。跨度启动和停止，并跟踪他们的时间信息。一旦你创建了一个跨度，你必须在将来某个时候停止它。开始追踪的初始跨度被称为 root span。该跨度的span id的值等于trace id 痕迹（Trace）：一组形成树状结构的跨度。例如，如果您正在运行分布式大数据存储，则跟踪可能由放入请求组成。","text":"Spring Cloud Sleuth： Spring Cloud Sleuth是为Spring Cloud实现了分布式追踪解决方案，Spring Cloud Sleuth借用了Dapper的术语： 跨度（Span）：基本的工作单位。例如，发送一个RPC是一个新的跨度，就像向RPC发送响应一样。跨度由跨度的唯一64位ID和跨度所包含的另一个 64位ID标识。Spans还具有其他数据，例如描述，时间戳事件，键值注释（标记），导致它们的跨度的ID以及进程ID（通常为IP地址）。跨度启动和停止，并跟踪他们的时间信息。一旦你创建了一个跨度，你必须在将来某个时候停止它。开始追踪的初始跨度被称为 root span。该跨度的span id的值等于trace id 痕迹（Trace）：一组形成树状结构的跨度。例如，如果您正在运行分布式大数据存储，则跟踪可能由放入请求组成。 标注（Annotation）：用于及时记录事件的存在。用于定义请求开始和结束的一些核心注释是 cs - 客户端发送 - 客户端发出请求。这个注释描述了跨度的开始。 sr - 服务器已收到 - 服务器端收到请求并开始处理。如果从这个时间戳中减去cs时间戳，将会收到网络延迟。 ss - 服务器发送 - 在请求处理完成时（当响应被发送回客户端时）注释。如果从这个时间戳中减去sr时间戳，将会收到服务器端处理请求所需的时间。 cr - 客户端收到 - 表示跨度结束。客户端已经成功接收到服务器端的响应。如果从这个时间戳中减去cs时间戳，那么将会收到客户端接收服务器响应所需的全部时间。 Span和Trace在系统中与Zipkin Annotation一起显示的可视化示例： Zipkin Zipkin是一个分布式追踪系统。它有助于收集解决微服务架构中延迟问题所需的时序数据。它管理这些数据的收集和查找。 应用程序用于向Zipkin报告时间数据。Zipkin UI还提供了一个依赖关系图，显示每个应用程序有多少跟踪请求。如果你正在解决延迟问题或错误问题，则可以根据应用程序，跟踪长度，注释或时间戳过滤或排序所有跟踪。一旦选择了一个跟踪，你可以看到每个跨度所花费的总跟踪时间的百分比，从而可以确定问题应用程序。 在SpringCloud中使用Zipkin： springcloud创建zipkin-server,依赖除了springcloud的基础依赖外再添加zipkin依赖，如下 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt; &lt;/dependency&gt; 启动类添加标签@EnableZipkinServer启动zipkin，代码如下 123456789101112/** * @author wxy */ @SpringBootApplication @EnableZipkinServer @EnableEurekaClient public class ZipKinServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZipKinServerApplication.class, args); &#125; &#125; 配置文件，如下 123456789101112spring: application: name: micoserice-zipkin-server server: port: 9994 eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ instance: instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; prefer-ip-address: true 启动后可直接访问localhost:9994，可看到zipkin的页面 ​ 除了这种方式还可通过docker安装，可查看教程https://github.com/openzipkin/zipkin 为微服务提供者消费者添加zipkin依赖和配置 ​ 添加依赖 12345&lt;!-- zipkin依赖jar--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; 添加配置 123456spring: zipkin: base-url: http://localhost:9994 sleuth: sampler: percentage: 1.0 spring.sleuth.sampler.percentage 是监控的百分比，默认的是0.1表示10%,这里给1.0表示全部监控spring.zipkin.base-url是zipkin-server的服务路径 依次启动服务如下 ​ ​ 我这里启动了zuul,ribbon以及user服务，通过zuul网管依次访问ribbon和user，查看zipkin如下图： ​ 示例代码：microservice-sleuth-zipkin-server 参考文档 http://cloud.spring.io/spring-cloud-static/Edgware.SR1/multi/multi__introduction.html ​ http://www.ityouknow.com/springcloud/2018/02/02/spring-cloud-sleuth-zipkin.html ​ https://zipkin.io/","categories":[{"name":"microservice","slug":"microservice","permalink":"http://wxiaoyang.top/categories/microservice/"},{"name":"springcloud","slug":"microservice/springcloud","permalink":"http://wxiaoyang.top/categories/microservice/springcloud/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://wxiaoyang.top/tags/springboot/"},{"name":"springcloud","slug":"springcloud","permalink":"http://wxiaoyang.top/tags/springcloud/"},{"name":"zipkin","slug":"zipkin","permalink":"http://wxiaoyang.top/tags/zipkin/"}]},{"title":"Spring Cloud网关zuul","slug":"zuul","date":"2018-01-11T07:32:25.000Z","updated":"2018-07-20T02:34:24.316Z","comments":true,"path":"2018/01/11/zuul/","link":"","permalink":"http://wxiaoyang.top/2018/01/11/zuul/","excerpt":"Zuul 简介 “Zuul is the front door for all requests from devices and web sites to the backend of the Netflix streaming application. As an edge service application, Zuul is built to enable dynamic routing, monitoring, resiliency and security. It also has the ability to route requests to multiple Amazon Auto Scaling Groups as appropriate.” 大致是说zuul是设备和网站到Netflix后台应用程序的所有的请求的前门，是一个边缘化应用程序，它的创建是为了实现动态路由，监控，弹性，和安全性， 它还能够根据需要将请求路由到多个Amazon Auto Scaling组。","text":"Zuul 简介 “Zuul is the front door for all requests from devices and web sites to the backend of the Netflix streaming application. As an edge service application, Zuul is built to enable dynamic routing, monitoring, resiliency and security. It also has the ability to route requests to multiple Amazon Auto Scaling Groups as appropriate.” 大致是说zuul是设备和网站到Netflix后台应用程序的所有的请求的前门，是一个边缘化应用程序，它的创建是为了实现动态路由，监控，弹性，和安全性， 它还能够根据需要将请求路由到多个Amazon Auto Scaling组。 来源’https://github.com/Netflix/zuul/wiki‘ zuul主要实现的功能就是API Gateway(api网关)的功能 为什么使用api gateway: 客户端会多次请求不同的微服务，导致客户端复杂度增加，使用网关时客户端只与网关交互，降低客户端的调用逻辑的复杂度，同时网关也可以实现认证逻辑简化内部服务的之间相互调用的复杂度。 对不同客户端的支持及数据的聚合，如一个网站有web端，手机端，页面所需的数据有同有异，可以将数据整合或者裁剪，减少客户端的请求次数，比如BFF架构。 可以更好的对项目的微服务封装，可将项目的微服务统一封装在一个内网环境中，只通过网关提供服务，同时网关也可以对安全，认证，监控，防御单独强化。 在springcloud使用zuul： ​ 1、除了添加eureka依赖外，添加zuul依赖包：123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;&lt;/dependency&gt; ​ 2、在启动类上使用@EnableZuulProxy 启用zuul 12345678910111213@SpringBootApplication@EnableZuulProxypublic class ZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplication.class, args); &#125;&#125; ​ 3、配置文件application.yml1234567891011121314spring: application: name: micoserice-gateway-zuulserver: port: 8090eureka: client: serviceUrl: defaultZone: &lt;http://localhost:8761/eureka/&gt; instance: prefer-ip-address: true instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 启动运行： 如图我这里启动了三个服务，zuul注册到Eureka-service为服务后默认情况下是构建PAI-GATEWAY，访问时只要zuul-host/appname/api 如我这里访问：http://localhost:8090/micoserice-user/user/getuser，当调用服务有多个时，zuul是实现了负载均衡的。 zuul中使用hystrix的回退 代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*** @author wxy* zuul中使用hystrix的回退*/@Componentpublic class MyFallbackProvider implements ZuulFallbackProvider &#123; @Override public String getRoute() &#123; //路由配置micoserice-user，如果全部用\"*\"代替 return \"micoserice-user\"; &#125; @Override public ClientHttpResponse fallbackResponse() &#123; return new ClientHttpResponse() &#123; @Override public HttpStatus getStatusCode() throws IOException &#123; //回退的状态码 return HttpStatus.OK; &#125; @Override public int getRawStatusCode() throws IOException &#123; //数字类型状态码 return 200; &#125; @Override public String getStatusText() throws IOException &#123; //状态文本 return \"ok\"; &#125; @Override public void close() &#123; &#125; @Override public InputStream getBody() throws IOException &#123; //回退响应体 return new ByteArrayInputStream(\"服务不可用稍后再试\".getBytes()); &#125; @Override public HttpHeaders getHeaders() &#123; //header设置 HttpHeaders headers = new HttpHeaders(); MediaType mediaType = new MediaType(\"application\",\"json\", Charset.forName(\"UTF-8\")); headers.setContentType(mediaType); return headers; &#125; &#125;; &#125;&#125; 添加回退后当访问micoserice-user 微服务失败后将会返回“服务不可用稍后再试”。 zuul过滤器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*** @author wxy* zuul过滤器* zuul中定义了四种标准过滤类型，这些过滤类型对应请求的生命周期** PRE:这种过滤类型在请求被路由之前调用。可利用这种过滤器实现身份验证，在集群中选择请求的微服务，记录调试信息等。** ROUTING:这种过滤器将请求路由到微服务。这种过滤用于构建发送给微服务的请求，* 并可以使用Apache HttpClient,Fegin,Ribbon请求微服务。** POST:这种过滤器在路由到微服务以后执行。这种过滤器可用来微响应添加标准的http header,* 搜集统计信息和指标，将响应发送给客户端。** ERROR:在其他阶段发生错误时执行该过滤器。**/public class RequestLogFilter extends ZuulFilter &#123; private static Logger logger = LoggerFactory.getLogger(RequestLogFilter.class); @Override public String filterType() &#123; return PRE_TYPE; &#125; @Override public int filterOrder() &#123; return 1; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; RequestContext requestContext =RequestContext.getCurrentContext(); HttpServletRequest request = requestContext.getRequest(); logger.info(String.format(\"send %s request to %s\",request.getMethod(),request.getRequestURL().toString())); return null; &#125;&#125;//在启动类下添加Bean@Beanpublic RequestLogFilter getRequestLogFilter()&#123;return new RequestLogFilter();&#125; 示例代码：microservice-gateway-zuul本文参考http://cloud.spring.io/spring-cloud-static/Finchley.M2/#_router_and_filter_zuulhttp://www.ityouknow.com/springcloud/2017/06/01/gateway-service-zuul.html http://microservices.io/patterns/apigateway.html","categories":[{"name":"microservice","slug":"microservice","permalink":"http://wxiaoyang.top/categories/microservice/"},{"name":"springcloud","slug":"microservice/springcloud","permalink":"http://wxiaoyang.top/categories/microservice/springcloud/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wxiaoyang.top/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://wxiaoyang.top/tags/springboot/"},{"name":"springcloud","slug":"springcloud","permalink":"http://wxiaoyang.top/tags/springcloud/"},{"name":"zuul","slug":"zuul","permalink":"http://wxiaoyang.top/tags/zuul/"}]}]}